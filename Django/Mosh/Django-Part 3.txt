setup the setting.py for media folder .for uploading image.
for imgae upload we have to first install the Pillow package. 

--------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------
setting.py=> 
---------------
from pathlib import Path


# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent
TEMPLATES_DIR = BASE_DIR / 'templates'
MEDIA_DIR = BASE_DIR / 'media'

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/4.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-oillj015g9y(t@95hv62d&!zp*jjrg06n$7h*y-vw7bgx!_7$6'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'django_filters',
    'rest_framework',
    'djoser', #this package for token base Auth.
    'playground',
    'store',
    'taqs',
    'likes', 
    'debug_toolbar',
    'faker',
    'core',
    
]
#token base Authentications => 
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework_simplejwt.authentication.JWTAuthentication',
       
    ),
}

from datetime import timedelta

SIMPLE_JWT = {
   'AUTH_HEADER_TYPES': ('JWT',),
    "ACCESS_TOKEN_LIFETIME": timedelta(days=1)
}




Djoser = {
    'SERIALIZER': {
        'user_create': 'core.serializers.UserCreateSerializer',
        'current_user': 'core.serializers.UserSerializer'
    }
}

AUTH_USER_MODEL = 'core.User' #appName.ModelName= core.User => core app customize the buildin django auth model.

MIDDLEWARE = [
    'debug_toolbar.middleware.DebugToolbarMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'storefront.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [TEMPLATES_DIR,],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

INTERNAL_IPS = [
    # ...
    "127.0.0.1",
    # ...
]

WSGI_APPLICATION = 'storefront.wsgi.application'


# Database
# https://docs.djangoproject.com/en/4.2/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'storefront',
        'HOST':'localhost',
        'PORT':'3306',
        'USER': 'storefront',
        'PASSWORD': '786Shuvo',
         'OPTIONS': {
            'init_command': "SET sql_mode='STRICT_TRANS_TABLES'",
        },
        
    }
}


# Password validation
# https://docs.djangoproject.com/en/4.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/4.2/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/4.2/howto/static-files/

STATIC_URL = 'static/'
MEDIA_URL = 'media/'
MEDIA_ROOT = MEDIA_DIR

# Default primary key field type
# https://docs.djangoproject.com/en/4.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'


# REST_FRAMEWORK = {
#     'PAGE_SIZE': 10
# }

REST_FRAMEWORK = {
    # 'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination', #if you default pagination then don't we it.
    # 'PAGE_SIZE': 10,  # Set your desired page size here( don't need if use default paginations).
}




----------------------------------------------------------
storefront::urls.py=> 
=======================
from django.contrib import admin
from django.urls import path, include
from playground import views
from django.conf import settings
from django.conf.urls.static import static



admin.site.site_header = "StoreFront " #admin page heading 
admin.site.index_title = "Admin" #admin page title

urlpatterns = [
    path('admin/', admin.site.urls),
    path('playground/', include('playground.urls')),
    path('store/', include('store.urls')),
    path('auth/',include('djoser.urls')),
    path('auth/',include('djoser.urls.jwt')),
    path("__debug__/", include("debug_toolbar.urls")),
] 

if settings.DEBUG:
    urlpatterns+=static(settings.MEDIA_URL , document_root = settings.MEDIA_ROOT)




>>> http://127.0.0.1:8000/media/MyIMG.jpg
--------------------------------------------
store::urls.py=> 
----------------
from django.urls import path
from store import views
#default router show the api endpoint urls.
from rest_framework_nested import routers


app_name = 'store'


router = routers.DefaultRouter()
router.register(r'product', views.ProductViewSet, basename='product') #assertions baseName error that's why add base name
router.register(r'collection', views.CollectionViewSet)
router.register(r'cart',views.CartViewSet,basename='cart')
router.register(r'customer', views.CustomerViewSet, basename='customer')
router.register(r'order', views.OrderViewSet, basename='order')

#for retrive reviews form product use => 
product_router = routers.NestedDefaultRouter(router, r'product', lookup='product')
product_router.register(r'review', views.ReviewViewSet, basename='product-reviews')
product_router.register(r'images',views.ProductIamgeViewSet, basename='images')

#for retrive cartItem form cart use=> 
cart_router = routers.NestedDefaultRouter(router, r'cart', lookup='cart') # send to cart_pk to CartItemViews.
cart_router.register(r'cartItem', views.CartItemViewSet, basename='cart-items') #basename has 2 route cart-item-detials/ cart-item-list #as nested routers

urlpatterns = [] + router.urls + product_router.urls + cart_router.urls 
------------------------------------------------------
store::model.py=> 
-----------------------
class ProductImage(models.Model):
    product = models.ForeignKey(Products, on_delete=models.CASCADE)
    image = models.ImageField(upload_to='store/images') #in medial folder -> media/store/img/= here store the img.

------------------------------------------------------
store::serializer.py=> 
--------------------------
# ==========================================Django Part 3===========================================
# ==========================================Product Image===========================================

from .models import ProductImage

class ProductImageSerializer(serializers.ModelSerializer):

    #create product image : 
    def create(self, validated_data):
        product_id = self.context['product_id']
        return ProductImage.objects.create(product_id=product_id,**validated_data)

    class Meta: 
        model = ProductImage
        fields = ['id', 'image']
--------------------------
--------------------------
store::views.py=> 
--------------------------
--------------------------
# ========================================Django Part 3========================================
# ========================================Product Image========================================

from .serializers import ProductImageSerializer
from .models import ProductImage

class ProductIamgeViewSet(ModelViewSet):
     serializer_class = ProductImageSerializer

     #for creat image in single product_id we need to pass : product id to serializers.
     def get_serializer_context(self) :
         return {'product_id':self.kwargs['product_pk']} #get product_id form urls
     
     #we jsut show 1 image for 1 product -> that's why we have to send product id to serializers
     def get_queryset(self):
          return ProductImage.objects.filter(product_id=self.kwargs['product_pk']) #get product_id form urls.
     
--------------------------

--------------------------------------------------------------------------------------------------
------------------------------Product with Product image show in localhost--------------------------------------------------------------------

store::urls.py=> 
------------------
from django.urls import path
from store import views
#default router show the api endpoint urls.
from rest_framework_nested import routers


app_name = 'store'


router = routers.DefaultRouter()
router.register(r'product', views.ProductViewSet, basename='product') #assertions baseName error that's why add base name
router.register(r'collection', views.CollectionViewSet)
router.register(r'cart',views.CartViewSet,basename='cart')
router.register(r'customer', views.CustomerViewSet, basename='customer')
router.register(r'order', views.OrderViewSet, basename='order')

#for retrive reviews form product use => 
product_router = routers.NestedDefaultRouter(router, r'product', lookup='product')
product_router.register(r'review', views.ReviewViewSet, basename='product-reviews')
product_router.register(r'images',views.ProductIamgeViewSet, basename='images')

#for retrive cartItem form cart use=> 
cart_router = routers.NestedDefaultRouter(router, r'cart', lookup='cart') # send to cart_pk to CartItemViews.
cart_router.register(r'cartItem', views.CartItemViewSet, basename='cart-items') #basename has 2 route cart-item-detials/ cart-item-list #as nested routers

urlpatterns = [] + router.urls + product_router.urls + cart_router.urls 
--------------------------------------
--------------------------------------
store::serializer.py=> 
--------------------------------------
--------------------------------------
from decimal import Decimal
from rest_framework import serializers
from store.models import Products,Collections,Review,Cart,CartItem,Customers,Order,OrderItems



# ==========================================Django Part 3===========================================
# ==========================================Product Image===========================================

from .models import ProductImage

class ProductImageSerializer(serializers.ModelSerializer):

    #create product image : 
    def create(self, validated_data):
        product_id = self.context['product_id']
        return ProductImage.objects.create(product_id=product_id,**validated_data)
    

    class Meta: 
        model = ProductImage
        fields = ['id', 'image']



# ==========================================Django Part 3===========================================

# class ProductSerializer(serializers.ModelSerializer):

#     images = ProductImageSerializer(many=True, read_only=True)
    

    
  
#     price = serializers.DecimalField(max_digits=6, decimal_places=2, source='unit_price') #custome name price => comes from unit_prime -> product(model)
#     price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')

#     def calculate_tax(self, product:Products):
#         return product.unit_price * Decimal(1.1)
    
#     class Meta : 
#         model = Products
#         fields = ['id','title', 'price', 'collections','price_with_tax','inventory','describtion','images'] #first search fields form model , if not find . then search => price , collections, tax_with price



# class ProductSerializer(serializers.ModelSerializer):
#     images = serializers.SerializerMethodField()

#     price = serializers.DecimalField(max_digits=6, decimal_places=2, source='unit_price')
#     price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')

#     def calculate_tax(self, product: Products):
#         return product.unit_price * Decimal(1.1)

#     def get_images(self, product: Products):
#         images = ProductImage.objects.filter(product=product)
#         return ProductImageSerializer(images, many=True).data

#     class Meta:
#         model = Products
#         fields = ['id', 'title', 'price', 'collections', 'price_with_tax', 'inventory', 'describtion', 'images']


# class ProductSerializer(serializers.ModelSerializer):
#     images = serializers.SerializerMethodField()

#     price = serializers.DecimalField(max_digits=6, decimal_places=2, source='unit_price')
#     price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')

#     def calculate_tax(self, product: Products):
#         return product.unit_price * Decimal(1.1)

#     def get_images(self, product: Products):
#         images = ProductImage.objects.filter(product=product)
#         return [{'id': img.id, 'image': self.context['request'].build_absolute_uri(img.image.url)} for img in images]

#     class Meta:
#         model = Products
#         fields = ['id', 'title', 'price', 'collections', 'price_with_tax', 'inventory', 'describtion', 'images']

class ProductSerializer(serializers.ModelSerializer):
    images = ProductImageSerializer(many=True, read_only=True)  # Assuming ProductImageSerializer is defined

    price = serializers.DecimalField(max_digits=6, decimal_places=2, source='unit_price')
    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')

    def calculate_tax(self, product: Products):
        return product.unit_price * Decimal(1.1)
    
    class Meta:
        model = Products
        fields = ['id', 'title', 'price', 'collections', 'price_with_tax', 'inventory', 'describtion', 'images']


# ----------------------------------------------------------------------------------------------
class CollectionsSerializer(serializers.ModelSerializer):
    products_count = serializers.IntegerField(read_only=True)  # Add this line

    class Meta: 
        model = Collections
        fields = ['id', 'title', 'products_count']

        


class ReviewSerializer(serializers.ModelSerializer):

    class Meta: 
        model = Review
        fields = ['id', 'date','name', 'describtion','product']

    #Receive data from context method form views.Reveiws (product_id, reviews_also )
    def create(self,validated_data):
        product_id = self.context ['product_id']
        return Review.objects.create(product_id=product_id,**validated_data)




#Cart take cartItems from CartItem serializers (parent - cart , child - cartItem):----------------------------

class SimpleProductSerializer(serializers.ModelSerializer):

    class Meta:
        model = Products
        fields = ['pk', 'title','unit_price']


class CartItemSerializer(serializers.ModelSerializer):
    product = SimpleProductSerializer() 
    total_price = serializers.SerializerMethodField()

    def get_total_price(self, cart_item: CartItem):
        return cart_item.quantity * cart_item.product.unit_price

    class Meta:
        model = CartItem
        fields = ['id', 'product', 'quantity', 'total_price']


class AddCartItemSerializer(serializers.ModelSerializer):
    product_id = serializers.IntegerField()

    class Meta:
        model = CartItem 
        fields = ['id','product_id','quantity'] #those field get from DB . if need extra data in varibale then we use self.request -> get data from url through get_context(self.kwagrs['paramsName-which get from urls/users']) for serializer.

    #data validation which get from url/users: if user input wrong product_id then => 
    def validate_product_id(self,value):
        if not Products.objects.filter(pk=value).exists():
            raise serializers.ValidationError('No Product Fount with the given ID')
        return value
    
    def save(self, **kwargs): #*** in serializer can't get params from urls , that's why use get_context() method in views to pass data into serializer.
        #in views we are using => serializer.is_validate():  -> serializer.save() 
        cart_id = self.context['cart_id'] #get from  views.context(method)
        product_id = self.validated_data['product_id'] #get from  urls
        quantity = self.validated_data['quantity'] #get from  urls

        try:
            cart_item = CartItem.objects.get(cart_id=cart_id, product_id=product_id)  #if get cart item then just update cartItem. and increase the quantity.
            cart_item.quantity += quantity
            cart_item.save()
            self.instance = cart_item#if Model get any data then update and return instance
        except CartItem.DoesNotExist:
            product = Products.objects.get(pk=product_id)
            self.instance = CartItem.objects.create(cart_id=cart_id, product=product, quantity=quantity)#if not found any cartItem then create new Item
             #  or user => 
             #  self.instance = CartItem.objects.create(cart_id=cart_id, **self.validated_data)
        return self.instance #if model not get any data then create new instance then return to db.


class UpdateCartItemSerializer(serializers.ModelSerializer):

    class Meta : 
        model = CartItem 
        fields = ['quantity']

        




class CartSerializer(serializers.ModelSerializer):
    id = serializers.UUIDField(read_only=True)
    items = CartItemSerializer(many=True, read_only=True )  # Set read_only=True
    total_price = serializers.SerializerMethodField()

    def get_total_price(self,cart:Cart):
        return sum([item.quantity * item.product.unit_price for item in cart.items.all()]) #most important Line.

    class Meta:
        model = Cart
        fields = ['id', 'items', 'total_price']



# ----------------------------------Customer Serializer-------------------------------------------------------

class CustomerSerializer(serializers.ModelSerializer):
    user_id = serializers.IntegerField(read_only=True)

    class Meta: 
        model = Customers
        fields = ['id', 'user_id', 'phone', 'email', 'birth_date', 'membership']








# ----------------------------------OrderItem Serializer-------------------------------------------------------

# class OrderItemSerializer(serializers.ModelSerializer):
#     product = SimpleProductSerializer()

#     class Meta: 
#         model = OrderItems
#         fields = ['id', 'product', 'unit_price', 'quantity']

class OrderItemSerializer(serializers.ModelSerializer):
    product = SimpleProductSerializer()

    class Meta: 
        model = OrderItems
        fields = ['id', 'product', 'unit_price', 'quantity']



# ----------------------------------Order Serializer-------------------------------------------------------

class OrderSerializer(serializers.ModelSerializer):

    items = OrderItemSerializer(many=True)

    class Meta:
        model = Order
        fields = ['id','payment_status', 'customers', 'place_order','items' ]


# ----------------------------------------Create OrderSerializer--------------------------------------------
from django.db import transaction
from .singnals import order_created #

class CreateOrderSerializer(serializers.Serializer):
     #we are not uing the model serializer here...

       #for real life senerio for creating order , we collect data from cart . that's why we use cart_id varibale here .
    cart_id = serializers.UUIDField()#for creating the order we collect cart_ID ,

    
    #if cart_id does not exit then user can't create the order: 
   
    
    
    def validate_cart_id(self, cart_id):
        if not Cart.objects.filter(pk=cart_id).exists() and Cart.objects.filter(pk=cart_id).count()==0 :
            raise serializers.ValidationError('Cart ID not found!')
        elif CartItem.objects.filter(cart_id=cart_id).count()==0:
            raise serializers.ValidationError('Cart is Empty!')
        return cart_id
  

    def save(self,**kwargs):
        with transaction.atomic():
            cart_id = self.validated_data['cart_id']#get from user form...
            user_id = self.context.get('user_id')#get from views.
            customer, created = Customers.objects.get_or_create(user_id=user_id)
            order = Order.objects.create(customers=customer)


            #for creating the order items : --------------------------------------------------------
        
            #create a cart_id then create a cart_items: then create OrderItems.
            #using CartItem model for filter card_id from cart table.(then we get the product )
            cart_items = CartItem.objects.filter(cart_id=cart_id).select_related('product')

            order_items = [
                OrderItems(
                    order=order,
                    product=item.product,
                    unit_price=item.product.unit_price,
                    quantity=item.quantity
                )
                for item in cart_items
            ]

            OrderItems.objects.bulk_create(order_items)

            #now delete the cartItem cz we use it for creating OrderItems: 

         

            #created singnal fn instance: 
            order_created.send_robust(self.__class__, order = order) #when created the order signal generated.
            
            # Corrected deletion of cart items
            # CartItem.objects.filter(cart_id=cart_id).delete()
            return order #return to the views-> create()

            #we using the model operations=>  order,OrderItem,CartItem, then delete the cartItem ,so if 1 operations 
            #fail then other operations working not properly .... if 1 operation is not work then otherOperations 
            #will stop. that's why we use Tracsictions ORM methods.






# -----------------------------------Udpdate serializers----------------------------------

class UpdateOrderSerializer(serializers.ModelSerializer):
    #just only update the payment_status
    class Meta: 
        model = Order 
        fields = ['payment_status']




--------------------------------------
--------------------------------------
store::views.py=> 
--------------------------------------

from rest_framework.response import Response #serializers to Json formater
from store.models import Products,Collections,OrderItems,Review,Cart,CartItem,Customers,Order, OrderItems
from store.serializers import ProductSerializer,CollectionsSerializer,ReviewSerializer,CartSerializer,CartItemSerializer,AddCartItemSerializer,UpdateCartItemSerializer,CustomerSerializer, OrderSerializer
from django.db.models import Count



from rest_framework.viewsets import ModelViewSet
from django_filters.rest_framework import DjangoFilterBackend# filter easyly with any Db.coloumn like price ...
from rest_framework.filters import SearchFilter,OrderingFilter # for search,sorting -> product 
from rest_framework.pagination import PageNumberPagination #paginations
from .filters import ProductFilter 
from store.paginations import DefaultPagination #cutom paginations.

#import for cart:
from rest_framework.mixins import CreateModelMixin,RetrieveModelMixin,ListModelMixin,DestroyModelMixin,UpdateModelMixin
from rest_framework.viewsets import GenericViewSet
from .permissions import IsAdminOrReadOnly

class ProductViewSet(ModelViewSet):

    queryset = Products.objects.all()
    serializer_class = ProductSerializer

    #for filter: =>-------------------------
    filter_backends = [DjangoFilterBackend,SearchFilter,OrderingFilter]
    # pagination_class = PageNumberPagination
    pagination_class = DefaultPagination  #custom paginations
    # filterset_fields = ['collections_id']
    filterset_class = ProductFilter #import form custom file.
    search_fields  = ['title', 'describtion'] #search box working with those fields.
    ordering_fields = ['unit_price','last_update']
    permission_classes = [IsAdminOrReadOnly]


    def get_serializer_context(self): #for serializer extra variable /mehtod to send to serializer
        return {'request':self.request}
    
    def destroy(self, request, *args, **kwargs):
          if OrderItems.objects.filter(product__id=kwargs['pk']).count() > 0:  #aggregations-> count(), ORM query fn-> Count().
                return Response({"error": "product can't be delete cause in orderitem"},)
         
          return super().destroy(request, *args, **kwargs)
  




# --------------------------------collections-------------------------------------



class CollectionViewSet(ModelViewSet):
        permission_classes = [IsAdminOrReadOnly]
        
        queryset = Collections.objects.annotate(products_count=Count('products')).all()
        serializer_class = CollectionsSerializer
        

        def destroy(self, request, *args, **kwargs):
             if OrderItems.products.filter(product__id=kwargs['pk']).count() > 0:  # Changed 'collection' to 'collection'
                return Response({'error': "collections can't be deleted because order items are included"})
             
             return super().destroy(request, *args, **kwargs)
       

class ReviewViewSet(ModelViewSet):
     #cutom query : cz reviews show for every product : filter review for indivisual products.
     def get_queryset(self):
         return Review.objects.filter(product_id =self.kwargs['product_pk'])
     

     #use this method for => send data to Review serializer
     def get_context_data(self) :
         return {'product_id':self.kwargs['product_pk']}
     
     
     serializer_class = ReviewSerializer


class CartViewSet(CreateModelMixin,RetrieveModelMixin,ListModelMixin,DestroyModelMixin,GenericViewSet):
     
    #  queryset = Cart.objects.all()
     queryset = Cart.objects.prefetch_related('items__product').all() #cart -> Fk-> CartItem(related_name=items), instide cartItem Fk-> Products(product) | optimize the query
     serializer_class = CartSerializer


#show single items of cart: 
class CartItemViewSet(ModelViewSet): #tabels need , cart_id, product_id, quantity in DB.
   
    #allow http method : 
    http_method_names = ['get', 'post','patch','delete'] #declare those methods which we want to use.

    #for add cartItem use custom serializer: 
    def get_serializer_class(self):
         if self.request.method == "POST":
              return AddCartItemSerializer #use for add new cartItem.
         elif self.request.method == "PATCH":
              return UpdateCartItemSerializer
         
         return CartItemSerializer # use for get() cartItem.
    

    def get_serializer_context(self): #data collect from urls , then send to serializer 
         return {'cart_id':self.kwargs['cart_pk']}
   


     #need single cartItem hast cart_id column , so need cart_ID+ to catch  :
    def get_queryset(self):
          return CartItem.objects.\
                        filter(cart_id=self.kwargs['cart_pk']).\
                        select_related('product')



#------------------------------Customer user -> JESON WEB TOKEN-------------------------------------------

from rest_framework.decorators import action #get, put, delete ...details = retrive...
from rest_framework.permissions import IsAuthenticated,AllowAny,DjangoModelPermissions,DjangoModelPermissionsOrAnonReadOnly#permisson for users
from .permissions import FullDjangoModelPermission,ViewCustomerModelPermission #cutom permission.

class CustomerViewSet(ModelViewSet):
     queryset = Customers.objects.all()
     serializer_class = CustomerSerializer
     permission_classes = [DjangoModelPermissionsOrAnonReadOnly] #use our custom class : FullDjangoModelPermission.


     @action(detail=True, permission_classes=[ViewCustomerModelPermission]) #custom model permission
     def history(self,request,pk):#http://127.0.0.1:8000/store/customer/1/history....
          return Response('ok')
     
     @action(detail=False, methods=['GET','PUT'], permission_classes=[IsAuthenticated()])
     def me(self, request):#http://127.0.0.1:8000/store/customer/me/ -> this /me = def me(function). & request.user -> anonimus functions of classes.
          customer, created = Customers.objects.get(user_id=request.user.id) #get -> method return 2 value: cutomerID, created/not_created boolean

          if request.method == 'GET':#also show the user id , but user_id can't edit by user. that's why make the CustomerSerializer -> user_id(read_only)
               serializer = CustomerSerializer(customer)
               return Response(serializer.data)

          elif request.method == 'PUT':
               serializer = CustomerSerializer(customer, data=request.data)
               serializer.is_valid(raise_exception=True)
               serializer.save()
               return Response(serializer.data)



# --------------------------------------order viewset----------------------------------------------

from .serializers import OrderSerializer,CreateOrderSerializer,OrderItemSerializer,UpdateOrderSerializer
from rest_framework.permissions import IsAdminUser, IsAuthenticated

class OrderViewSet(ModelViewSet):
    # permission_classes = [IsAuthenticated]
    #ALLOW THE METHOD 
    # http_method_names = ['get','patch','delete','head','options']

    # route permission: 
    # def get_permissions(self):
    #     if self.request.method in ['POST','DELETE']:
    #          return [IsAdminUser()] 
    #     return [IsAuthenticated()]

    # after createing the orderItem user can see the order: that's why use this create methods.
    # def create(self, request, *args, **kwargs):
    #     serializer = CreateOrderSerializer(data=request.data, context={'user_id': self.request.user.id})
    #     serializer.is_valid(raise_exception=True)
    #     order = serializer.save()
    #     serializer = OrderItemSerializer(order)
    #     return Response(serializer.data)




    def get_serializer_class(self):
        if self.request.method == "POST":
            return CreateOrderSerializer
        elif self.request.method == "PUT":
             return UpdateOrderSerializer
        return OrderSerializer

    def get_serializer_context(self): 
        return {'user_id': self.request.user.id} #send to serializer the user.id....

    def get_queryset(self):
        user = self.request.user

        if user.is_staff: #if user hast permission as an stuff then can see the order.
            return Order.objects.all()

        customer, created = Customers.objects.only('id').get(user_id=user.id)
        return Order.objects.filter(customers=customer) #send to the serializer 

   

# ========================================Django Part 3========================================
# ========================================Product Image========================================

from .serializers import ProductImageSerializer
from .models import ProductImage

class ProductIamgeViewSet(ModelViewSet):
     
     serializer_class = ProductImageSerializer

     #to creat image for single product_id we need to pass : product id to serializers.
     def get_serializer_context(self) :
         return {'product_id':self.kwargs['product_pk']} #get product_id form urls
     
     #we jsut show 1 image for 1 product -> that's why we have to send product id to serializers
     def get_queryset(self):
          return ProductImage.objects.filter(product_id=self.kwargs['product_pk']) #get product_id form urls.
     
--------------------------------------
--------------------------------------
store::models.py=> 
---------------------------
from django.db import models
from uuid import uuid4 #for generate cart unique number.

#import for users links with profile: 
from django.conf import settings
#improt admin for display first_name, last_name as ordering : 
from django.contrib import admin

# Create your models here.


class Promotions(models.Model):
    describtion = models.CharField(max_length=255)
    discount = models.FloatField()


class Collections(models.Model):
    title = models.CharField(max_length=255)
    featured_product = models.ForeignKey('Products',on_delete=models.SET_NULL, null=True, related_name='+')

    def __str__(self):
        return self.title 
    
    class Meta:
        ordering = ['title']

    


class Products (models.Model):
    slug = models.SlugField()
    sku = models.CharField(max_length=10)
    title = models.CharField(max_length=255)
    describtion = models.TextField()
    unit_price = models.DecimalField(max_digits=10, decimal_places=2) 
    inventory = models.IntegerField()
    last_update = models.DateTimeField(auto_now=True)
    collections = models.ForeignKey(Collections,on_delete=models.PROTECT,related_name='products') # if want to delete Collections , Before must be delete Products .
    promotions = models.ManyToManyField(Promotions)

    def __str__(self) -> str:
        return self.title
    
    class Meta: 
        ordering = ['title']



class ProductImage(models.Model):
    product = models.ForeignKey(Products, on_delete=models.CASCADE,related_name='product')
    image = models.ImageField(upload_to='store/images') #in medial folder -> media/store/img/= here store the img.



class Customers(models.Model):
    MEMBERSHIP_BRONZE = 'B'
    MEMBERSHIP_SILVER = 'S'
    MEMBERSHIP_GOLD = 'G'
    MEMBERSHIP_CHOICES = [
        ('MEMBERSHIP_BRONZE', 'Bronze'),
        ('MEMBERSHIP_SILVER', 'Silver'),
        ('MEMBERSHIP_GOLD', 'Gold'),
    ]

    first_name = models.CharField(max_length=255)
    last_name = models.CharField(max_length=255)
    email = models.EmailField(unique=True)
    phone = models.IntegerField(null=True)
    birth_date = models.DateField(null=True)
    membership = models.CharField(max_length=17, choices=MEMBERSHIP_CHOICES, default=MEMBERSHIP_BRONZE)
    user = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)

    @admin.display(ordering='user__first_name')
    def first_name(self):
        return self.user.first_name
    
    @admin.display(ordering='user__last_name')
    def last_name(self):
        return self.user.last_name
    
    def get_order_count(self):
        return self.order_set.count()

    class Meta:
        ordering = ['user__first_name', 'user__last_name']


        #custom model permission: 
        permissions = [('view_history', 'Can view history')]
        #then run >>> python manage.py makemigrations, migrate...


class Order(models.Model):
    PAYMENT_STATUS_PENDING = 'P'
    PAYMENT_STATUS_COMPLETE = 'C'
    PAYMENT_STATUS_FAILD = 'F'
    PAYMENT_STATUS_CHOICE = [
        ('PAYMENT_STATUS_PENDING','P'),
        ('PAYMENT_STATUS_COMPLETE','C'),
        ('PAYMENT_STATUS_FAILD','F'),
    ]
    place_order = models.DateTimeField(auto_now_add=True)
    payment_status = models.CharField(
    max_length=23, choices=PAYMENT_STATUS_CHOICE, default=PAYMENT_STATUS_PENDING
    )

    customers = models.ForeignKey(Customers, on_delete=models.PROTECT) #if accidently delete the Customers , we don't delete the order .

    class Meta: 
        permissions=[
            ('cancel_order', 'Can cancel Order')
        ]


class OrderItems(models.Model):
    order = models.ForeignKey(Order,on_delete=models.PROTECT, related_name='items')
    product = models.ForeignKey(Products,on_delete=models.PROTECT, related_name='orderItems')
    quantity = models.PositiveSmallIntegerField()
    unit_price = models.DecimalField(max_digits=6,decimal_places=2)

class Cart(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid4)
    created_at = models.DateTimeField(auto_now_add=True)

class Address(models.Model):
    street = models.CharField(max_length=255)  # Corrected max_length
    city = models.CharField(max_length=255)  
    

    #one to one relationship
    Customers = models.OneToOneField(Customers,on_delete=models.CASCADE, primary_key=True ) 

class CartItem(models.Model):
    cart = models.ForeignKey(Cart,on_delete=models.CASCADE, related_name='items') #
    product = models.ForeignKey(Products,on_delete=models.CASCADE)
    quantity = models.PositiveSmallIntegerField()

    unique_together = [['cart','products']] #for unique generated....



class Review(models.Model):
    product = models.ForeignKey(Products,on_delete=models.CASCADE, related_name='review')
    name = models.CharField(max_length=255)
    describtion = models.TextField()
    date = models.DateField(auto_now_add=True)


--------------------------------------

--------------------------------------------------------------------------------------------------
------------------------------File size validators--------------------------------------------------------------------
--------------------------------------------------------------------------------------------------
store::validator.py=> 
-----------------------
from django.core.exceptions import ValidationError


def validate_file_size(file):

    max_size_kb = 50

    if file.size > max_size_kb * 1024:
        raise ValidationError(f'File size can\'t be more than {max_size_kb}kb')


-------------------------------
-------------------------------
store::models.py=> 
-------------------------------
-------------------------------
from store.validators import validate_file_size

class ProductImage(models.Model):
    product = models.ForeignKey(Products, on_delete=models.CASCADE,related_name='product')
    image = models.ImageField(upload_to='store/images', validators=[validate_file_size]) #in medial folder -> media/store/img/= here store the img.

>>>> http://127.0.0.1:8000/store/product/1/images/ | now upload the file and check the error .
-------------------------------
-------------------------------
file extension validators=> store::models.py
--------------------------------------------
from store.validators import validate_file_size
from django.core.validators import MinValueValidator, FileExtensionValidator #file extensions checkers.

class ProductImage(models.Model):
    product = models.ForeignKey(Products, on_delete=models.CASCADE,related_name='product')
    image = models.ImageField(upload_to='store/images', validators=[validate_file_size,FileExtensionValidator(allowed_extensions=['pdf'])]) #in medial folder -> media/store/img/= here store the img.



--------------------------------------------------------------------------------------------------
-----------------------------------Djaong Core Origin---------------------------------------------------------------
# when img upload localhost:8001(client side address) to localhost:8000(django backend address) , we have to install a package>>> 'django-cors-header'
>>> set up settings, install app, middleware, and add >  CORS_ALLOWED_ORIGINS= ['http://127.0.0.1:8001']
--------------------------------------------------------------------------------------------------
------------------------------- Add Product IMG in Admin Panel -------------------------------------------------------------------
store:: admin.py => 
--------------------
from django.db import models

from typing import Any
from django.contrib import admin
from django.db.models.query import QuerySet
from django.http.request import HttpRequest
from django.db.models import Count,Min,Max,Avg,Sum
from .models import ProductImage
from . import models
from django.utils.html import format_html


#for show the product image: 
class ProductImageInline(admin.TabularInline): #for show img in admin panel .
    model = ProductImage
    readonly_fields = ['thumbnail']

    def thumbnail(self,instance):
        if instance.image.name !='':
            return format_html(f'<img src="{instance.image.url}"  class="thumbnail"   > ')
        return ''

@admin.register(models.Products)
class ProductAdmin(admin.ModelAdmin):
    list_display = ['title', 'unit_price', 'inventory_status', 'collections_title'] # show the title and unit_price in admin page, product has a link with collections table with collections column.
    list_editable = ['unit_price'] #now can edit -> 'unit_price' column.
    inlines = [ProductImageInline] #********show img in admin panel .
    list_per_page = 10 #paginations .
    ordering = ['title', 'unit_price'] #accending order with titel and followed by unit_price.
    list_select_related = ['collections'] # Product Fk with Collections , collections form collections table in Product table

    #import custom css from static folder: 
    class Media: 
        css = {
            'all':['/static/img.css']
        }

    def collections_title(self,product): #this product varible reffer to the Product Models.
        return product.collections.title 


    #return inventory coloumn in admin panel as string : 
    # if inventory is < 10 : show low or show 'high'

    @admin.display(ordering='inventory') # show admin panael inventory as accending order.
    def inventory_status(self, product): # this product varibale work with 'inventory_status' column.
        if product.inventory < 10:
            return 'Low'
        return 'Ok'
    
    
    

@admin.register(models.Order)
class OrderAdmin(admin.ModelAdmin):
    list_display = ['id', 'place_order', 'customers', 'payment_status']
    list_editable = ['payment_status']
    list_per_page = 10

    

    def place_order(self, order):
        return order.place_order

    def customers(self, order):
        return order.Customers


# @admin.register(models.Customers)
# class CustomerAdmin(admin.ModelAdmin):
#     list_display = ['first_name', 'last_name', 'membership','orders']
#     list_editable = ['membership']
#     list_per_page = 10
#     list_select_related = ['user']
#     ordering = ['user__first_name', 'user__last_name']

from django.contrib import admin
from .models import Customers, Order

# @admin.register(Customers)
# class CustomerAdmin(admin.ModelAdmin):
#     list_display = ['first_name', 'last_name', 'membership', 'display_orders']
#     list_editable = ['membership']
#     list_per_page = 10
    


#     """
#         In this case, obj will be an instance of the Customers model because we're working within the CustomerAdmin class.
#           This means obj will represent a specific customer.
#     """
#     def display_orders(self, obj):
#         orders = Order.objects.filter(Customers=obj)
#         return ', '.join([str(order.id) for order in orders])



#     display_orders.short_description = 'Orders' #admin panel name is Orders

@admin.register(models.Customers)
class CustomerAdmin(admin.ModelAdmin):
    list_display = ['first_name', 'last_name', 'membership', 'get_order_count']
    list_editable = ['membership']
    list_per_page = 10
    list_select_related = ['user']
    ordering = ['user__first_name', 'user__last_name']

    def get_order_count(self, obj):
        return obj.order_set.count() #customer parent , order child fk with customer. so , customer get order_set as default relative name.
    get_order_count.admin_order_field = 'order_set_count'
    get_order_count.short_description = 'Order Count'



#insert custom table with annotate -------------------------------

@admin.register(models.Collections)
class CollectionsAdmin(admin.ModelAdmin):
    list_display = ['title', 'featured_product', 'product_count']
    list_editable = ['featured_product']

    def product_count(self, collections):
        return collections.product_count

    def get_queryset(self, request):
        return super().get_queryset(request).annotate(
            product_count=Count('products') # this variable comes from Collections Models. if reserve error then change the Variable name
        )


# Register your models here.
# admin.site.register(models.Collections) or use => @admin.register(models.Collections)

-------------------------
-------------------------
#create a new folder inside store app >> static>>> img.css 
-------------------------
.thumbnail{
    width: 100px;
    height: 100px;
    object-fit: cover;
}
-------------------------
--------------------------------------------------------------------------------------------------
--------------------------------Send Main : SMTP server setup with Docker------------------------------------------------------------------
--------------------------------------------------------------------------------------------------
amshu@DESKTOP-DQD3N2V MINGW64 /i/Django Code Practice From Mosh/1.Django First Part (django3rd-part)
$ docker pull rnwood/smtp4dev
Using default tag: latest
Error response from daemon: Head "https://registry-1.docker.io/v2/rnwood/smtp4dev/manifests/latest": unauthorized: incorrect username or password

amshu@DESKTOP-DQD3N2V MINGW64 /i/Django Code Practice From Mosh/1.Django First Part (django3rd-part)
$ docker login -u amshuvo64
Password: 
Login Succeeded

Logging in with your password grants your terminal complete access to your account.
For better security, log in with a limited-privilege personal access token. Learn more at https://docs.docker.com/go/access-tokens/

amshu@DESKTOP-DQD3N2V MINGW64 /i/Django Code Practice From Mosh/1.Django First Part (django3rd-part)
$ docker pull rnwood/smtp4dev
Using default tag: latest
latest: Pulling from rnwood/smtp4dev
68ced04f60ab: Pull complete
4ddb1a571238: Pull complete
94b78a0446e2: Pull complete
b48f8e1b0b06: Pull complete
a41ea3d79519: Pull complete
020abfffe9ae: Pull complete
Digest: sha256:9888dd5d2d4464a815b6b166d7b62bb7a91180d26e5117a54c791c31cf17fccd
Status: Downloaded newer image for rnwood/smtp4dev:latest
docker.io/rnwood/smtp4dev:latest

What's Next?
  View summary of image vulnerabilities and recommendations â†’ docker scout quickview rnwood/smtp4dev

amshu@DESKTOP-DQD3N2V MINGW64 /i/Django Code Practice From Mosh/1.Django First Part (django3rd-part)
$ docker run --rm -it -p 3000:80 -p 2525:25 rnwood/smtp4dev
smtp4dev version 3.1.4
https://github.com/rnwood/smtp4dev
.NET Core runtime version: .NET Core 3.1.2


>>>>> localhost:3000


---------------------------------------------------------------------------------------------------------
---------------------------------------Configure Fake SMTP------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
storefront::setting.py => 
--------------------------

#fake smtp configure: --------------------------------

EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = 'localhost'
EMAIL_HOST_USER = ''
EMAIL_HOST_PASSWORD = ''
EMAIL_PORT = 2525
DEFAULT_FROM_EMAIL = 'from@shuvo.com'
------------------------------------
playground::urls.py-> 
----------------------
#fake smtp configure: --------------------------------

EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = 'localhost'
EMAIL_HOST_USER = ''
EMAIL_HOST_PASSWORD = ''
EMAIL_PORT = 2525
DEFAULT_FROM_EMAIL = 'from@shuvo.com'

ADMINS = [
    ('Shuvo', 'kali@Shuvo.com')
]
------------------------
------------------------
playground::views.py=> 
------------------------
from django.shortcuts import render
from django.http import HttpResponse 
from django.core.mail import send_mail, mail_admins, send_mass_mail,BadHeaderError #for log main address use send_mass_mail

# Create your views here.

def calculate():
    x = 1
    y = 2
    return x

def say_hello(request):
    x = calculate()
    try:
        # send_mail('subject', 'message', 'info@shuvo.com',['bob@shuvo.com']) #From:	info@shuvo.com ; To:	bob@shuvo.com
        mail_admins('subject','message plain text',html_message='hello sms')


        #send Mail with file: 
        message = EmailMessage('subject','message','from@shuvo.com', ['get@shuvo.com'])
        message.attach_file('playground/static/img/MyIMG.jpg')
        message.send()    
    except BadHeaderError:
        pass
    return render(request, 'hello.html',{"name":"Shuvo"})
    # return HttpResponse("Hello World")




def sendMain(request):
    try:
        send_mail('subject', 'message', 'info@shuvo.com',['bob@shuvo.com'])
    except BadHeaderError:
        pass
    return render(request, 'hello.html',{"name":"Shuvo"})
------------------------
playground::views.py=> 
----------------------
-------------------------------------Templated Mail--------------------------------------------------------------------
#for template mail : download the package => django-templated-mail . 

#inside playground app >>> create folder >>> email >>> hello.html=> 
------------------------------------------------------------------
{% block subject%}
<h1>this is the new subject</h1>
{% endblock%}


{% block massage_body%}
<h1>Hello {{name}}!</h1>
{% endblock%}
---------------------------------------------------------------------
playground::views.py=> 
------------------------
from django.shortcuts import render
from django.http import HttpResponse 
from django.core.mail import EmailMessage,send_mail, mail_admins, send_mass_mail,BadHeaderError #for log main address use send_mass_mail
from templated_mail.mail import BaseEmailMessage
# Create your views here.

def calculate():
    x = 1
    y = 2
    return x

def say_hello(request):
    x = calculate()
    try:
        # send_mail('subject', 'message', 'info@shuvo.com',['bob@shuvo.com']) #From:	info@shuvo.com ; To:	bob@shuvo.com
        # mail_admins('subject','message plain text',html_message='hello sms')  

        #send Mail with file: -------------------------
        # message = EmailMessage('subject','message','from@shuvo.com', ['get@shuvo.com'])
        # message.attach_file('playground/static/img/MyIMG.jpg')
        # message.send()

        #Email with html page+dynamic Mail:---------------------------
        message = BaseEmailMessage(
            template_name='hello.html',
            context={'name':'Shuvo'}
        )
        message.send(['get@shuvo.com'])

    except BadHeaderError:
        pass
    return render(request, 'hello.html',{"name":"Shuvo"})
    # return HttpResponse("Hello World")




def sendMain(request):
    try:
        send_mail('subject', 'message', 'info@shuvo.com',['bob@shuvo.com'])
    except BadHeaderError:
        pass
    return render(request, 'hello.html',{"name":"Shuvo"})
-------------------------------
setting.py => 
-------------------------------
#fake smtp configure: --------------------------------

EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = 'localhost'
EMAIL_HOST_USER = ''
EMAIL_HOST_PASSWORD = ''
EMAIL_PORT = 2525
DEFAULT_FROM_EMAIL = 'from@shuvo.com'

ADMINS = [
    ('Shuvo', 'kali@Shuvo.com')
]
---------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
-------------------------------------Jobs & queue(Celery,radis-bacground Tasks)--------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
#Long Running Task : 
-------------------
1. processing img & video . 
2. generating report 
3. sending email 
4. Running meching learing models . 

#running process in background .
 
in celery provide multi workers to run multi tasks in background .

    EX: App -> Queue(message brokers-middle man) -> workers1,workers2....(worker take jobs from queue )

*** this workers don't impact on our Main Applications process. 
*** in specific time we can run workers to do jobs in backgrounds. 

# App -> queue(message broker claster) -> clientApp [if client app in offline then , message broker send sms when client active]

**** we use message broker to reliable  delivery massge between apps.

1. redis => works as a message broker + caching 
2. rabbitMQ => (real enterprice level message broker.)
---------------------------------------------------------
---------------------------------------------------------
# installing redis image on docker => >>> docker run -d -p 6379:6379 redis
---------------------------------------------------------
---------------------------------------------------------
#install redis on django. >>> pip install redis
---------------------------------------------------------
---------------------------------------------------------
#install celery on django >>> pip install celery 

------------------------------------Celery Configurations:---------------------------------------------------------------------

storefront:celery.py=> 
----------------------

#------------------------this code is work-------------------------------

from __future__ import absolute_import, unicode_literals
import os
from celery import Celery

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'storefront.settings')

app = Celery('storefront')
app.config_from_object('django.conf:settings', namespace='CELERY')
app.autodiscover_tasks()




# -------------------------------------------------------------
# import os
# from celery import Celery

# #setup environment varible: as storefront.settings: 
# os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'storefront.settings')



# #create celery: 
# celery = Celery('storefront')

# #where celery find the setting : 
# celery.config_from_object('django.conf:settings',namespace='Celery')

# celery.autodiscover_tasks()



------------------------------
------------------------------
storefront::settings.py=> 
----------------------
#for celery : SET redis server. 

# CELERY_BROKER_URL = 'redis://localhost:6379/1' #here /1 = is a database name #now this redis run inside the docker container. 



CELERY_BROKER_URL = 'redis://localhost:6379/1'
CELERY_RESULT_BACKEND = 'redis://localhost:6379/1'


from celery.schedules import crontab


------------------------------
storefront::__init__.py=> 
-------------------------
# from .celerys import celery




from __future__ import absolute_import, unicode_literals

# This will make sure the app is always imported when
# Django starts so that shared_task will use this app.
from .celery import app as celery_app

__all__ = ('celery_app',)

------------------------------
------------------------------
then run on terminal >>> celery -A ProjectName WorkersName dubugingForTesting

>>>> celery -A storefront worker --loglevel=info | for linux command [kill my 3 hours] *****

>>> celery -A storefront worker --pool=save --l info | for windwos command .
------------------------------
------------------------------
------------------------------

----------------------------------for long task with celery :task.py-----------------------------------------------------------------------

playground::tasks.py=>:set the task that will do by worker in background (sending 10k mail to customers)
-----------------------

from time import sleep 
from celery import shared_task

@shared_task
def notify_customers(message): 
    print('Sending 10k sms')
    print(message)
    sleep(10)
    print('Email were success fully send ')
-------------------------
-------------------------
playground::views.py=> 
---------------------
from django.shortcuts import render

from .task import notify_customers
# Create your views here.



def say_hello(request):

    #celery task for sending message: inside the dely write the sms => which pass to the notify_cusotmers: 
    notify_customers.delay("Hello ")



    return render(request, 'hello.html',{"name":"Shuvo"})



-------------------------
-------------------------

---------------------------------------Scheduling Priodic Task------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
settings.py=> 
---------------
CELERY_BROKER_URL = 'redis://localhost:6379/1'
CELERY_RESULT_BACKEND = 'redis://localhost:6379/1'

from celery.schedules import crontab

CELERY_BEAT_SCHEDULE = {
    'notify_customers': {
        'task': 'playground.task.notify_customers',
        'schedule': 5, # seconds
        # 'schedule': crontab(day_of_month=10, day_of_week=1, hour=7,minute=30), # fixed time
        'args': ['Hello world'], 
        'kwargs': {}
    }
}


>>> celery -A storefront beat 
every 5 second print the sms. 

---------------------------------------------------------------------------------------------------------
-------------------------------------------check the celery task on control panel --------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
>>> pip install flower

>>> celery -A storefront flower 
---------------------------------------------------------------------------------------------------------
-----------------------------------Automate Testing: ----------------------------------------------------------------------

HTTP error => 401 [unauthorized]
=> 403 [noAmin]
=> 400 [admin & invalid data ]
=> 200 [admin & data ]
---------------------------------------------------------------------------------------------------------
-----------------------------------------Unit test + PyTest----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
when start testing > just check the api functions / not fix or impletement code at this time . 
>>>> after testing then fix the code . 



# install pytest in develop mode for testing code .
>>> pip install --dev pytest


>>> pip install pytest | windwos
>>> pip install pytest-django | windwos
---------------------------------------------------------------------------------------------------------
MianProjectFolder::pytest.ini=> 
--------------------------------
[pytest]

DJANGO_SETTINGS_MODULE = storefront.settings 


---------------------------------------------------------------------------------------------------------
store::tests::test_collections_api.py=> 
---------------------------------------
#(Arrange,Act,Assert): 
from rest_framework.test import APIClient
from rest_framework import status
import pytest

@pytest.mark.django_db
class TestCreateCollections: 
    @pytest.mark.skip #for skip this test | use this decorators
    def test_if_user_anonimous_return_401(self):
        

        #Arragen: 


        #Act: check the app behaviour=> 
        client = APIClient()
        response = client.post('/store/collection/',{'title': 'a'})


        #Assert: working or not => True/Fasle

        assert response.status_code == status.HTTP_403_FORBIDDEN
        # assert response.status_code == status.HTTP_401_UNAUTHORIZED
------------------------------------------------------------------
goto to cmd and run => >>> pytest 

#run a signal pytest | signal pytest class => 
---------------------------------------------
>>> pytest store/tests/test_collections_api.py::TestCreateCollections 
>>> pytest folderLocations/fileName.py::className.

# check anonimus test=> 
-----------------------
>>> pytest -k anonimus    | -k -> key: nameOfTest.

-------------------------------------Continous test run when change in coding--------------------------------------------------------------------

>>>install >>> pip install pytest-watch
>>> ptw | this command to run the test continously. when change the code. 


-------------------------------------Run pytest in VSCODE--------------------------------------------------------------------

>> select the jur icon >>> run & debug . 
>> select pytest >>> select root directory. 
>> run the test . [I don't like it .VSCODE test | pytest is 1000% of better.]
---------------------------------------------------------------------------------------------------------
--------------------------------------Run Multiple endpoint assertions test.-------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
store::tests::test_collections_api=> 
======================================
#(Arrange,Act,Assert): 
from django.contrib.auth.models import User
from rest_framework.test import APIClient
from rest_framework import status
import pytest

@pytest.mark.django_db
class TestCreateCollections: 
    # @pytest.mark.skip    #for skip this test
    def test_if_user_anonimous_return_401(self):
        

        #Arragen: 


        #Act: check the app behaviour=> 
        client = APIClient()
        # client.force_authenticate(user={}) #make the user as authenticated.
        client.force_authenticate(user=User(is_staff=True)) #make the user as authenticated.
        response = client.post('/store/collection/',{"title":""})


        #Assert: working or not => True/Fasle

        assert response.status_code == status.HTTP_400_BAD_REQUEST #check the bad request.
        # assert response.status_code == status.HTTP_401_UNAUTHORIZED
        # assert response.status_code == status.HTTP_401_UNAUTHORIZED


    def test_if_collections_is_created_201(self):
        

        #Arragen: 


        #Act: check the app behaviour=> 
        client = APIClient()
        client.force_authenticate(user=User(is_staff=True)) #make the user as authenticated.
        response = client.post('/store/collection/',{"title":"Testing by Pytest"})


        #Assert: working or not => True/Fasle

        assert response.status_code == status.HTTP_201_CREATED
        assert response.data['id'] > 0
        # assert response.status_code == status.HTTP_401_UNAUTHORIZED
---------------------------------------------------------------------------------------------------------
--------------------------------------Fixture: fix some test.-------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
some repetative thing like , authorize user set , client api set...etc we fix in another file=> 

in fixture use model bakery for create object for models. for testing purpose.
>>> pip install model-bakery
----------------
----------------
store::conftest.py=>  
--------------------
--------------------
from rest_framework.test import APIClient
import pytest
from django.contrib.auth.models import User

from rest_framework import status

@pytest.fixture
def api_client(): #this fixture works for end_api
    return APIClient


@pytest.fixture
def authenticate(api_client):# in api_client parameter we pass the authenticate_user.
    def do_authenticate(is_staff=False):
        return api_client.force_authenticate(user=User(is_staff=is_staff))
    return do_authenticate
    



--------------------
--------------------
store::tests::test_collections_api.py=> 
----------------------------------------
#(Arrange,Act,Assert): 
from django.contrib.auth.models import User
from rest_framework import status
import pytest
from store.models import Collections,Products
from model_bakery import baker # for creating the models objects ,test purpose.
from rest_framework.test import APIClient



#create fixture for api_end_point: 
@pytest.fixture
def create_collection(api_client):

    def do_create_collection(collection):
        return api_client().post('/store/collection/', collection)
    # def do_create_collection(collection):#receive api {'title':'value'}
    #     return api_client.post('/store/collection',collection)
    return do_create_collection


@pytest.mark.django_db
class TestCreateCollections: 
    # @pytest.mark.skip    #for skip this test
    def test_if_user_anonimous_return_401(self,create_collection): #this api_client,collection from fixture.
        
        response = create_collection({'title':'a'}) #this function call from fixture
        
        assert response.status_code == status.HTTP_201_CREATED #check the bad request.
       


    def test_if_collections_is_created_201(self,create_collection):
        
        response = create_collection({'title':'a'}) #this function call from fixture
       

        assert response.status_code == status.HTTP_201_CREATED
        assert response.data['id'] > 0
        # assert response.status_code == status.HTTP_401_UNAUTHORIZED





# ======================================================
import pytest
from rest_framework import status
from store.models import Collections
from model_bakery import baker

@pytest.mark.django_db
class TestRetriveCollection():
    def test_is_collection_exit_return_200(self, api_client):
        # Create a collection using model_bakery
        collection = baker.make(Collections)

        # Make a GET request to retrieve the collection
        response = api_client().get(f'/store/collection/{collection.id}/') #if we miss '/' end of the api url , error : 301. 

        # Check if the response status code is 200 OK
        assert response.status_code == status.HTTP_200_OK

        # Check if the response data matches the expected values
        assert response.data == {
            'id': collection.id,
            'title': collection.title,
            'products_count': 0  # Assuming products_count is expected to be 0
        }

 # collection = baker.make(Collections) #make collections object for model .
        # baker.make(Products,collection=collection, _quantity=10) #create 10 product for 1 collections.

        # assert False
----------------
---------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
---------------------------------------Performance Test(Locast)------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
for Performance test use Locust. 

>>> pip install locust


------------------------------------
MainProductFile::locustfiles::browse_products.py=> 
-----------------------------------------------

from locust import HttpUser,task,between
from random import randint


class WebsiteUser(HttpUser):
    #view products
    #views product details
    # add product to cart

    wait_time = between(1,5) #waiting time is (1sec,5sec):

    @task(4) #we can use this task_number as our wish. 
    def view_products(self):
        print('view products')

        collection_id = randint(1,10)
        self.client.get(f'/store/product/?collection_id={collection_id}', name='/store/product') #want to show dirrent type fo collections products , that's why use randint.
        #product has a FK with collections_id , that why we can use => /store/product/?collection_id=2.(find the collections id of the product.)

    @task(2)
    def view_product(self): #single product.
        print('view products details')
        product_id = randint(1,999)
        self.client.get(f'/store/product/{product_id}', name='/store/product/:id')


    @task(1)
    def add_to_cart(self): # here cart_id value comes from 'def on_start':
        print('add to cart')
        product_id = randint(1, 10)
        self.client.get(f'/store/cart/{self.cart_id}/cartItem/',
                        name='/store/cart/cartItem',
                        json={
                            'product_id': product_id,
                            'quantity': 1
                        })


    #it's call everytime to new user to browse our website, it's not task , life cycle hood:
    def on_start(self):
        response = self.client.post(f'/store/cart/')
        result = response.json()
        self.cart_id = result['id']

    

-----------------------------------------------


to run the locust >>>>locust -f locustfiles/browse_products.py      | here locustfiles is folder name > file name > browse_product.py

#then goto >>> localhost:8089

>>> set django_server_address in input field of the locust=>  http://127.0.0.1:8000/ 


---------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
# goto product views=> and => remove prefetch_related(). 

>>> goto settings >>> middeware >>> comment out -> debug_toolbar

>>> restart locust >>> set user : 500 ; spwan rate :10 & set the localhost: .

# in localhost we get the relative Performance test result , but in real life (domain+hosting.) we get actual Performance Test
---------------------------------------------------------------------------------------------------------
------------------------------------** performance Optimizations technique**------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
use in ORM: preload_related_objects.
--------------
1. Model.objects.select_related('fk_related_name...')          # use for single FK relationship id with the tables.
2. Model.objects.prefetch_related('fk_related_name...')        #use for multi FK relationship id with the tables.

-----------
load only what we need : 
------------------------
------------------------
Product.objects.only(...) 
Product.objects.differ(...)

-------------------------
-------------------------
count properly=> 
-------------------------
Product.objects.count(...)
len(Proudct.obejects.all()) #Bad 
-------------------------
-------------------------
use Value+Value_list: 
------------------------
Product.obejects.Value() # return dictionary.
Product.obejects.Value_list() # return list.


------------------------
------------------------
for crud use: -> efficiently
------------------------
Product.obejects.bulk_create()
Product.obejects.bulk_update()
------------------------

if still slow then use raw query .... 
1. customize with raw query 
2. Tune Database (re-design models)
3. lastly use caching (Redis).
---------------------------------------------------------------------------------------------------------
---------------------------------------Django silk: find slow query------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
>>> pip install django-silk 
--------------------------------------------
setting.py=> 
----------------
from pathlib import Path


# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent
TEMPLATES_DIR = BASE_DIR / 'templates'
MEDIA_DIR = BASE_DIR / 'media'

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/4.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-oillj015g9y(t@95hv62d&!zp*jjrg06n$7h*y-vw7bgx!_7$6'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'django_filters',
    'rest_framework',
    'djoser', #this package for token base Auth.
    'silk',
    'playground',
    'store',
    'taqs',
    'likes', 
    'debug_toolbar',
    'faker',
    'core',
    'corsheaders',
    
]
#token base Authentications => 
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework_simplejwt.authentication.JWTAuthentication',
       
    ),
}

from datetime import timedelta

SIMPLE_JWT = {
   'AUTH_HEADER_TYPES': ('JWT',),
    "ACCESS_TOKEN_LIFETIME": timedelta(days=1)
}




Djoser = {
    'SERIALIZER': {
        'user_create': 'core.serializers.UserCreateSerializer',
        'current_user': 'core.serializers.UserSerializer'
    }
}

AUTH_USER_MODEL = 'core.User' #appName.ModelName= core.User => core app customize the buildin django auth model.

MIDDLEWARE = [
     "corsheaders.middleware.CorsMiddleware",
    # 'debug_toolbar.middleware.DebugToolbarMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    
]

if DEBUG: 
    MIDDLEWARE += ['silk.middleware.SilkyMiddleware']

ROOT_URLCONF = 'storefront.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [TEMPLATES_DIR,],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]


CORS_ALLOWED_ORIGINS= ['http://127.0.0.1:8001']


INTERNAL_IPS = [
    # ...
    "127.0.0.1",
    # ...
]

WSGI_APPLICATION = 'storefront.wsgi.application'


# Database
# https://docs.djangoproject.com/en/4.2/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'storefront',
        'HOST':'localhost',
        'PORT':'3306',
        'USER': 'storefront',
        'PASSWORD': '786Shuvo',
         'OPTIONS': {
            'init_command': "SET sql_mode='STRICT_TRANS_TABLES'",
        },
        
    }
}


# Password validation
# https://docs.djangoproject.com/en/4.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/4.2/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/4.2/howto/static-files/

STATIC_URL = 'static/'
MEDIA_URL = 'media/'
MEDIA_ROOT = MEDIA_DIR

# Default primary key field type
# https://docs.djangoproject.com/en/4.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'


# REST_FRAMEWORK = {
#     'PAGE_SIZE': 10
# }

REST_FRAMEWORK = {
    # 'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination', #if you default pagination then don't we it.
    # 'PAGE_SIZE': 10,  # Set your desired page size here( don't need if use default paginations).
}


#fake smtp configure: --------------------------------

EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = 'localhost'
EMAIL_HOST_USER = ''
EMAIL_HOST_PASSWORD = ''
EMAIL_PORT = 2525
DEFAULT_FROM_EMAIL = 'from@shuvo.com'

ADMINS = [
    ('Shuvo', 'kali@Shuvo.com')
]

#for celery : SET redis server. 

# CELERY_BROKER_URL = 'redis://localhost:6379/1' #here /1 = is a database name #now this redis run inside the docker container. 



CELERY_BROKER_URL = 'redis://localhost:6379/1'
CELERY_RESULT_BACKEND = 'redis://localhost:6379/1'

# from celery.schedules import crontab

# CELERY_BEAT_SCHEDULE = {
#     'notify_customers': {
#         'task': 'playground.task.notify_customers',
#         'schedule': 5, # seconds
#         # 'schedule': crontab(day_of_month=10, day_of_week=1, hour=7,minute=30), # fixed time
#         'args': ['Hello world'], 
#         'kwargs': {}
#     }
# }

--------------------------------------------

goto silk dashboard >>>http://localhost:8000/silk/

>>> after locust run > stop it then reffer >>> silk dashboard and file slow query . 

**** after optimize the query >>> setting.py >>> comment out > SilkyMiddleware . then run locust again and 
check the performance for 500 users. 
---------------------------------------------------------------------------------------------------------
---------------------------------------Caching Redis------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
playground::views.py=> create the views for 2 second delay | for testing the caching...
---------------------
from django.shortcuts import render
import requests


def say_hello(request):

    requests.get('https://httpbin.org/delay/2')

    return render(request, 'hello.html', {"name": "Shuvo"})





-----------------------------
-----------------------------
goto >> locustfiles::browse_product.py=> 
----------------------------------------
from locust import HttpUser,task,between
from random import randint


class WebsiteUser(HttpUser):
    #view products
    #views product details
    # add product to cart

    wait_time = between(1,5) #waiting time is (1sec,5sec):

    @task(4) #we can use this task_number as our wish. 
    def view_products(self):
        print('view products')

        collection_id = randint(1,10)
        self.client.get(f'/store/product/?collection_id={collection_id}', name='/store/product') #want to show dirrent type fo collections products , that's why use randint.
        #product has a FK with collections_id , that why we can use => /store/product/?collection_id=2.(find the collections id of the product.)

    @task(2)
    def view_product(self): #single product.
        print('view products details')
        product_id = randint(1,999)
        self.client.get(f'/store/product/{product_id}', name='/store/product/:id')


    @task(1)
    def add_to_cart(self): # here cart_id value comes from 'def on_start':
        print('add to cart')
        product_id = randint(1, 10)
        self.client.get(f'/store/cart/{self.cart_id}/cartItem/',
                        name='/store/cart/cartItem',
                        json={
                            'product_id': product_id,
                            'quantity': 1
                        })
    
    @task(5) #add this funcitons for checking the Caching of Redis. ****
    def say_hello(self):
        print('say hello form playground app ')
        self.client.get('/playground/hello/')


    #it's call everytime to new user to browse our website, it's not task , life cycle hood:
    def on_start(self):
        response = self.client.post(f'/store/cart/')
        result = response.json()
        self.cart_id = result['id']

    

    


-----------------------------
run redis in docker => >>> docker run -d -p 6379:6379 redis 

---------------------------------
---------------------------------
install django-redis >>> pip install django-redis       | and configure the settings.
---------------------------------
---------------------------------------------------------------------------------------------------------
-------------------------------------Low level caching --------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
playground::views.py=> 
--------------------
from django.shortcuts import render
import requests
from django.core.cache import cache


def say_hello(request):
    key = 'httpbin_result'
    if cache.get(key) is None: 
        response = requests.get('https://httpbin.org/delay/2')
        data = response.json()
        cache.set(key,data)        # cache.get(key,data,10*60) last valie indecate the caching timeout. 

    return render(request, 'hello.html', {'name': cache.get(key)})



setting.py=> 
-------------
#------------------------------------------django redis

CACHES = {
    "default": {
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": "redis://127.0.0.1:6379/2",
        "TIMEOUT": 10*60, #custome caching timeout . . . 
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
        }
    }
}
---------------------------------------------------------------------------------------------------------
------------------------------------------caching with decoretors---------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
playground::views.py=> 
------------------------

from django.shortcuts import render
import requests
from django.core.cache import cache
from django.views.decorators.cache import cache_page


@cache_page(10*60)
def say_hello(request):
        response = requests.get('https://httpbin.org/delay/2')
        data = response.json()
   
        return render(request, 'hello.html', {'name': data})

---------------------------------------------------------------------------------------------------------
---------------------------------------------class base decorator------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
playround::urls.py=> 
-------------------
from django.urls import path
from playground import views

app_name = 'playground'

urlpatterns = [
    path('hello/', views.SayHello.as_view(), name='hello'),
]
========================
playground::views.py=> 
========================
from django.shortcuts import render
import requests
from django.core.cache import cache
from django.utils.decorators import method_decorator
from django.views.decorators.cache import cache_page
from rest_framework.views import APIView


class SayHello(APIView):
        @method_decorator(cache_page(10*60))
        def get(self,request):
            response = requests.get('https://httpbin.org/delay/2')
            data = response.json()
            return render(request, 'hello.html', {'name': data})
-----------------------------
-------------------------------------------------------------
now check the locust with 500user. for caching optimizations.
-----------------------------
-----------------------------
goto docker cli >>> checkout the cache file . in setting we set the redis as database numbers: 2

run redis cli inside the docker => 

>>>>docker exec -it 5cfac4ddbdae redis-cli

-----------------------------
amshu@DESKTOP-DQD3N2V MINGW64 /i/Django Code Practice From Mosh/1.Django First Part (django3rd-part)
$ docker exec -it 5cfac4ddbdae redis-cli
127.0.0.1:6379> select 2
OK

127.0.0.1:6379[2]> keys *
(empty array)
127.0.0.1:6379[2]> keys *
1) ":1:views.decorators.cache.cache_header..e58e888c06a2cff7ef17b423ce360397.en-us.UTC"
2) ":1:views.decorators.cache.cache_page..GET.e58e888c06a2cff7ef17b423ce360397.d41d8cd98f00b204e9800998ecf8427e.en-us.UTC"

127.0.0.1:6379[2]> flushall
OK
127.0.0.1:6379[2]>

-----------------------------
-----------------------------



---------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------

