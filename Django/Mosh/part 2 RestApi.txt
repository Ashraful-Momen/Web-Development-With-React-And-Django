
----------------------------------------------RESTAPI FRAMEWORK--------------------------------------------
>>> pip install djangorestframework
>>> pip freeze > requirments.txt
>>> setup with install apps in settings.py 

-------------------------------------------------
Model > Serializer > views (serializer.data<- convert to Dictionary) 
-------------------------------------------------
mainProject::StoreFront::urls.py=> 
----------------------------------
admin.site.site_header = "StoreFront " #admin page heading 
admin.site.index_title = "Admin" #admin page title

urlpatterns = [
    path('admin/', admin.site.urls),
    path('',views.product_list,name='index_page'),
    path('playground/', include('playground.urls')),
    path('store/', include('store.urls')),
    path("__debug__/", include("debug_toolbar.urls")),
]


--------------------------------
--------------------------------
store::urls.py=> 
-----------------
from django.urls import path
from store import views

urlpatterns = [
    path('product_list/',views.product_list,name='product_list' ),
    path('product/<int:id>/',views.product,name='product' ),
]
--------------------------------
--------------------------------
store::views.py=> 
-----------------
from django.shortcuts import render
from django.http import HttpResponse
from rest_framework.decorators import api_view 
from rest_framework.response import Response 
# Create your views here.

@api_view()
def product_list(request):
    return Response("Ok")

@api_view()
def product(request,id):
    return Response(id)
--------------------------------
--------------------------------
-------------------------------------------------------------------------------------------------------------
--------------------------------------Serializer Custom Feilds-----------------------------------------------
-------------------------------------------------------------------------------------------------------------
store::models.py=> 
------------------
from django.db import models

# Create your models here.


class Promotions(models.Model):
    describtion = models.CharField(max_length=255)
    discount = models.FloatField()


class Collections(models.Model):
    title = models.CharField(max_length=255)
    featured_product = models.ForeignKey('Products',on_delete=models.SET_NULL, null=True, related_name='+')

    def __str__(self):
        return self.title 
    
    class Meta:
        ordering = ['title']

    


class Products (models.Model):
    slug = models.SlugField()
    sku = models.CharField(max_length=10,primary_key=True)
    title = models.CharField(max_length=255)
    describtion = models.TextField()
    unit_price = models.DecimalField(max_digits=10, decimal_places=2) 
    inventory = models.IntegerField()
    last_update = models.DateTimeField(auto_now=True)
    collections = models.ForeignKey(Collections,on_delete=models.PROTECT) # if want to delete Collections , Before must be delete Products .
    promotions = models.ManyToManyField(Promotions)

    def __str__(self) -> str:
        return self.title
    
    class Meta: 
        ordering = ['title']




class Customers(models.Model):
    MEMBERSHIP_BRONZE = 'B'
    MEMBERSHIP_SLIVER = 'S'
    MEMBERSHIP_GOLD = 'G'
    MEMBERSHIP_CHOICE = [
    ('MEMBERSHIP_BRONZE','Bronze'),
    ('MEMBERSHIP_SLIVER','Silver'),
    ('MEMBERSHIP_GOLD','Gold'),
    ]

    first_name = models.CharField(max_length=255)
    last_name = models.CharField(max_length=255)
    email = models.EmailField(unique=True)
    phone = models.IntegerField()
    brith_date = models.DateField(null=True)
    membership = models.CharField(max_length=17, choices=MEMBERSHIP_CHOICE, default=MEMBERSHIP_BRONZE)
    
    def __str__(self):
        return f"{self.first_name} {self.last_name }"


    class Meta:
        ordering = ['first_name', 'last_name']



class Order(models.Model):
    PAYMENT_STATUS_PENDING = 'P'
    PAYMENT_STATUS_COMPLETE = 'C'
    PAYMENT_STATUS_FAILD = 'F'
    PAYMENT_STATUS_CHOICE = [
        ('PAYMENT_STATUS_PENDING','P'),
        ('PAYMENT_STATUS_COMPLETE','C'),
        ('PAYMENT_STATUS_FAILD','F'),
    ]
    place_order = models.DateTimeField(auto_now_add=True)
    payment_status = models.CharField(
    max_length=23, choices=PAYMENT_STATUS_CHOICE, default=PAYMENT_STATUS_PENDING
    )

    Customers = models.ForeignKey(Customers,on_delete=models.PROTECT) #if accidently delete the Customers , we don't delete the order .

class OrderItems(models.Model):
    order = models.ForeignKey(Order,on_delete=models.PROTECT)
    Products = models.ForeignKey(Products,on_delete=models.PROTECT)
    quentity = models.PositiveSmallIntegerField()
    unit_price = models.DecimalField(max_digits=6,decimal_places=2)

class Cart(models.Model):
    created_at = models.DateTimeField(auto_now_add=True)

class Address(models.Model):
    street = models.CharField(max_length=255)  # Corrected max_length
    city = models.CharField(max_length=255)  
    

    #one to one relationship
    Customers = models.OneToOneField(Customers,on_delete=models.CASCADE, primary_key=True ) 

class CartItem(models.Model):
    cart = models.ForeignKey(Cart,on_delete=models.CASCADE)
    Products = models.ForeignKey(Products,on_delete=models.CASCADE)
    quantitiy = models.PositiveSmallIntegerField()



-------------------------------------------------------
#Serializer=> Convert Model instance  into a Dictionary.
-------------
from rest_framework import serializers


class ProductSerializer(serializers.Serializer):

    # id = serializers.IntegerField()
    title = serializers.CharField(max_length= 255)
    unit_price = serializers.DecimalField(max_digits=6, decimal_places=2)

---------------------------
store::urls.py => 
---------------------------
from django.urls import path
from store import views

urlpatterns = [
    path('product_list/',views.product_list,name='product_list' ),
    # path('product/<int:id>/',views.product,name='product' ),
    path('product/<str:sku>/', views.product, name='product'),

]
---------------------------
---------------------------
store::views.py=> 
------------------
from django.shortcuts import render
from django.http import HttpResponse


from rest_framework.decorators import api_view 
from rest_framework.response import Response 
from store.models import Products
from store.serializers import ProductSerializer
@api_view()
def product_list(request):
    return Response("Ok")

# @api_view()
# def product(request,sku):
#     product = Products.objects.get(pk=sku)
#     serializer = ProductSerializer(product)

#     return Response(serializer.data) #dajango autometically convert the data to json formate.


@api_view()
def product(request, sku):
    try:
        product = Products.objects.get(pk=sku)
        serializer = ProductSerializer(product)
        return Response(serializer.data)
    except Products.DoesNotExist:
        return Response({"error": "Product not found"}, status=404)

---------------------------
---------------------------

-------------------------------------------------------------------------------------------------------------
------------------------Add custom field in serializer: not exit in Models feilds.--------------------
-------------------------------------------------------------------------------------------------------------
store::serializers.py=> 
=========================
from decimal import Decimal
from rest_framework import serializers
from store.models import Products


class ProductSerializer(serializers.Serializer):

    # id = serializers.IntegerField()
    title = serializers.CharField(max_length= 255)
    price = serializers.DecimalField(max_digits=6, decimal_places=2, source='unit_price') #custome name price => comes from unit_prime -> product(model)

    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')

    def calculate_tax(self, product:Products):
        return product.unit_price * Decimal(1.1)

-------------------------------------------------------------------------------------------------------------
--------------------------------serializer relationship-----------------------------------------------
-------------------------------------------------------------------------------------------------------------
Way-1=> product serializer relationship with collections. 
-----------------------------------------
from decimal import Decimal
from rest_framework import serializers
from store.models import Products,Collections


class ProductSerializer(serializers.Serializer):
    #here user Product models vaibale as default.

    # id = serializers.IntegerField()
    title = serializers.CharField(max_length= 255)
    price = serializers.DecimalField(max_digits=6, decimal_places=2, source='unit_price') #custome name price => comes from unit_prime -> product(model)
    
    #relations with collectionsmodels , way1=> 
    collections = serializers.PrimaryKeyRelatedField(
        queryset = Collections.objects.all()
    )


    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')

    def calculate_tax(self, product:Products):
        return product.unit_price * Decimal(1.1)
    


-------------------------------------------
way-2 to 4 together.=> 
-------------------------------------------
store::serializers.py=> 
------------------------
from decimal import Decimal
from rest_framework import serializers
from store.models import Products,Collections



# class CollectionsSerializer(serializers.Serializer):
#     id = serializers.IntegerField() #django auto primary key
#     title = serializers.CharField(max_length= 255)

class ProductSerializer(serializers.Serializer):
    #here user Product models vaibale as default.

    # id = serializers.IntegerField()
    title = serializers.CharField(max_length= 255)
    price = serializers.DecimalField(max_digits=6, decimal_places=2, source='unit_price') #custome name price => comes from unit_prime -> product(model)
    
    #relations with collectionsmodels , way1=> --------------------------------
    # collections = serializers.PrimaryKeyRelatedField(
    #     queryset = Collections.objects.all()
    # )
    #end===============================================

    #relations with collections models , way2=>------------------------------------
    # collections = serializers.StringRelatedField()
    # end===============================================


    #relations with collectionsmodels , way3=>------------------------------------
    # collections = CollectionsSerializer()
    # end===============================================

    #relations with collectionsmodels , way4=>------------------------------------
    #if click the collection then go to collection-detials views.+Product_list views also

    collections = serializers.HyperlinkedRelatedField(
        queryset = Collections.objects.all(),
        view_name='collection-detials'
    )
    # end===============================================

    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')

    def calculate_tax(self, product:Products):
        return product.unit_price * Decimal(1.1)
    





-------------------------------------------
store::urls.py=>
-----------------
from django.urls import path
from store import views

urlpatterns = [
    path('product_list/',views.product_list,name='product_list' ),
    # path('product/<int:id>/',views.product,name='product' ),
    path('product/<str:sku>/', views.product, name='product'),
    path('collections/<int:pk>/', views.collection, name='collection-detials'), # serializer method - 4 . 

]
-------------------------------------------
-------------------------------------------
store::views.py=>
-------------------
from django.shortcuts import render
from django.http import HttpResponse


from rest_framework.decorators import api_view 
from rest_framework import generics
from rest_framework.response import Response 
from store.models import Products,Collections
from store.serializers import ProductSerializer



@api_view()
def product_list(request):
    products = Products.objects.select_related('collections').all()
    serializer = ProductSerializer(products, many=True, context={'request': request})
    return Response(serializer.data)


# @api_view()
# def product(request,sku):
#     product = Products.objects.get(pk=sku)
#     serializer = ProductSerializer(product)

#     return Response(serializer.data) #dajango autometically convert the data to json formate.


@api_view()
def product(request, sku):
    try:
        product = Products.objects.get(pk=sku)
        serializer = ProductSerializer(product)
        return Response(serializer.data)
    except Products.DoesNotExist:
        return Response({"error": "Product not found"}, status=404)


@api_view()
def collection(request,pk):
    return Response('ok')
    



-------------------------------------------
-------------------------------------------



-------------------------------------------------------------------------------------------------------------
------------------------------------Serializer Model fields-------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
In Serializer data filed comes form Modles fields ['fieldName','add_custom_fileds']. if we want to use custom field 
belows model fileds , user custom_felids = [unit_price] 
-------------------------------------------
store::serializer.py=> 
----------------------
from decimal import Decimal
from rest_framework import serializers
from store.models import Products,Collections



# class CollectionsSerializer(serializers.Serializer):
#     id = serializers.IntegerField() #django auto primary key
#     title = serializers.CharField(max_length= 255)

class ProductSerializer(serializers.ModelSerializer):
    

    class Meta : 
        model = Products
        fields = ['title', 'price', 'collections','price_with_tax'] #first search fields form model , if not find . then search => price , collections, tax_with price

  
    price = serializers.DecimalField(max_digits=6, decimal_places=2, source='unit_price') #custome name price => comes from unit_prime -> product(model)
    
    collections = serializers.HyperlinkedRelatedField(
        queryset = Collections.objects.all(),
        view_name='collection-detials'
    )

    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')

    def calculate_tax(self, product:Products):
        return product.unit_price * Decimal(1.1)
    



-------------------------------------------
-------------------------------------------------------------------------------------------------------------
--------------------------------------Deserializer : Post (add product to DB)+CRUD--------------------------------------------
-------------------------------------------------------------------------------------------------------------

from django.shortcuts import render
from django.http import HttpResponse


from rest_framework.decorators import api_view 
from rest_framework import generics
from rest_framework.response import Response 
from store.models import Products,Collections
from store.serializers import ProductSerializer



@api_view(['GET','POST'])
def product_list(request):
    if request.method == 'GET':
        products = Products.objects.select_related('collections').all()
        serializer = ProductSerializer(products, many=True, context={'request': request})
        return Response(serializer.data)
    

    elif request.method=='POST': #deserializer is send data to DB with POST.
        serializer = ProductSerializer(data= request.data)
        # serializer.validated_data
        return Response('ok')




-------------------------------------------------------------------------------------------------------------
-------------------------------------------Data Validations-------------------------------------------
--------------------------serializer.is_valid(raise_exception=True)------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------
from django.shortcuts import render
from django.http import HttpResponse


from rest_framework.decorators import api_view 
from rest_framework import generics
from rest_framework.response import Response 
from store.models import Products,Collections
from store.serializers import ProductSerializer



@api_view(['GET','POST'])
def product_list(request):
    if request.method == 'GET':
        products = Products.objects.select_related('collections').all()
        serializer = ProductSerializer(products, many=True, context={'request': request})
        return Response(serializer.data)
    

    elif request.method=='POST': #deserializer is send data to DB with POST.
        serializer = ProductSerializer(data= request.data)
        serializer.is_valid(raise_exception=True) #if Error => then raise Error massage.
        serializer.validated_data
        return Response('ok')


# @api_view()
# def product(request,sku):
#     product = Products.objects.get(pk=sku)
#     serializer = ProductSerializer(product)

#     return Response(serializer.data) #dajango autometically convert the data to json formate.


@api_view()
def product(request, sku):
    try:
        product = Products.objects.get(pk=sku)
        serializer = ProductSerializer(product)
        return Response(serializer.data)
    except Products.DoesNotExist:
        return Response({"error": "Product not found"}, status=404)


@api_view()
def collection(request,pk):
    return Response('ok')
    



-------------------------------------------------------------------------------------------------------------
--------------------------------------Product : create and Update & DELETE-----------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
store::views.py=> 
------------------
from django.shortcuts import render
from django.http import HttpResponse


from rest_framework.decorators import api_view 
from rest_framework import generics
from rest_framework.response import Response 
from store.models import Products,Collections
from store.serializers import ProductSerializer
from django.shortcuts import get_object_or_404
from rest_framework.status import HTTP_200_OK,HTTP_201_CREATED,HTTP_204_NO_CONTENT
from django.db.models import Count



@api_view(['GET','POST'])
def product_list(request):
    if request.method == 'GET':
        products = Products.objects.select_related('collections').all()
        serializer = ProductSerializer(products, many=True, context={'request': request})
        return Response(serializer.data)
    

    elif request.method=='POST': #Create Product----------------------------------------
        serializer = ProductSerializer(data= request.data)
        serializer.is_valid(raise_exception=True) #if Error => then raise Error massage.
        serializer.save()
        return Response(serializer.data, status=HTTP_200_OK)



@api_view(['GET', 'PUT','DELETE'])
def product_details(request, sku): #Read/Update/Delete Product----------------------------------------
    product = get_object_or_404(Products, pk=sku)

    if request.method == 'GET':
        serializer = ProductSerializer(product)
        return Response(serializer.data)
    elif request.method == 'PUT': 
        serializer = ProductSerializer(product, data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data, status=HTTP_201_CREATED)
    elif request.method =='DELETE':
        if product.orderItems.count() > 0:  #aggregations-> count(), ORM query fn-> Count().
            return Response({"error": "product can't be delete cause in orderitem"},)
        product.delete()
        return Response(status=HTTP_204_NO_CONTENT)



@api_view()
def collection(request,pk):
    return Response('ok')
    


------------------------------
store::urls.py=> 
------------------------------
from django.urls import path
from store import views

urlpatterns = [
    path('product_list/',views.product_list,name='product_list' ),
    path('product/<str:sku>/', views.product_details, name='product'),
    path('collections/<int:pk>/', views.collection, name='collection-detials'), # serializer method - 4 . 

]
------------------------------
------------------------------
store::serializer.py=>
------------------------------
from decimal import Decimal
from rest_framework import serializers
from store.models import Products,Collections

class ProductSerializer(serializers.ModelSerializer):
    

    class Meta : 
        model = Products
        fields = ['title', 'price', 'collections','price_with_tax','inventory','describtion'] #first search fields form model , if not find . then search => price , collections, tax_with price

  
    price = serializers.DecimalField(max_digits=6, decimal_places=2, source='unit_price') #custome name price => comes from unit_prime -> product(model)
    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')

    def calculate_tax(self, product:Products):
        return product.unit_price * Decimal(1.1)
    




------------------------------
------------------------------
store::models.py=> 
-----------------------
from django.db import models

# Create your models here.


class Promotions(models.Model):
    describtion = models.CharField(max_length=255)
    discount = models.FloatField()


class Collections(models.Model):
    title = models.CharField(max_length=255)
    featured_product = models.ForeignKey('Products',on_delete=models.SET_NULL, null=True, related_name='+')

    def __str__(self):
        return self.title 
    
    class Meta:
        ordering = ['title']

    


class Products (models.Model):
    slug = models.SlugField()
    sku = models.CharField(max_length=10,primary_key=True)
    title = models.CharField(max_length=255)
    describtion = models.TextField()
    unit_price = models.DecimalField(max_digits=10, decimal_places=2) 
    inventory = models.IntegerField()
    last_update = models.DateTimeField(auto_now=True)
    collections = models.ForeignKey(Collections,on_delete=models.PROTECT) # if want to delete Collections , Before must be delete Products .
    promotions = models.ManyToManyField(Promotions)

    def __str__(self) -> str:
        return self.title
    
    class Meta: 
        ordering = ['title']




class Customers(models.Model):
    MEMBERSHIP_BRONZE = 'B'
    MEMBERSHIP_SLIVER = 'S'
    MEMBERSHIP_GOLD = 'G'
    MEMBERSHIP_CHOICE = [
    ('MEMBERSHIP_BRONZE','Bronze'),
    ('MEMBERSHIP_SLIVER','Silver'),
    ('MEMBERSHIP_GOLD','Gold'),
    ]

    first_name = models.CharField(max_length=255)
    last_name = models.CharField(max_length=255)
    email = models.EmailField(unique=True)
    phone = models.IntegerField()
    brith_date = models.DateField(null=True)
    membership = models.CharField(max_length=17, choices=MEMBERSHIP_CHOICE, default=MEMBERSHIP_BRONZE)
    
    def __str__(self):
        return f"{self.first_name} {self.last_name }"


    class Meta:
        ordering = ['first_name', 'last_name']



class Order(models.Model):
    PAYMENT_STATUS_PENDING = 'P'
    PAYMENT_STATUS_COMPLETE = 'C'
    PAYMENT_STATUS_FAILD = 'F'
    PAYMENT_STATUS_CHOICE = [
        ('PAYMENT_STATUS_PENDING','P'),
        ('PAYMENT_STATUS_COMPLETE','C'),
        ('PAYMENT_STATUS_FAILD','F'),
    ]
    place_order = models.DateTimeField(auto_now_add=True)
    payment_status = models.CharField(
    max_length=23, choices=PAYMENT_STATUS_CHOICE, default=PAYMENT_STATUS_PENDING
    )

    Customers = models.ForeignKey(Customers,on_delete=models.PROTECT) #if accidently delete the Customers , we don't delete the order .

class OrderItems(models.Model):
    order = models.ForeignKey(Order,on_delete=models.PROTECT)
    Products = models.ForeignKey(Products,on_delete=models.PROTECT, related_name='orderItems')
    quentity = models.PositiveSmallIntegerField()
    unit_price = models.DecimalField(max_digits=6,decimal_places=2)

class Cart(models.Model):
    created_at = models.DateTimeField(auto_now_add=True)

class Address(models.Model):
    street = models.CharField(max_length=255)  # Corrected max_length
    city = models.CharField(max_length=255)  
    

    #one to one relationship
    Customers = models.OneToOneField(Customers,on_delete=models.CASCADE, primary_key=True ) 

class CartItem(models.Model):
    cart = models.ForeignKey(Cart,on_delete=models.CASCADE)
    Products = models.ForeignKey(Products,on_delete=models.CASCADE)
    quantitiy = models.PositiveSmallIntegerField()
------------------------------
------------------------------


-------------------------------------------------------------------------------------------------------------
--------------------------------------collections:Crud-----------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
store::models.py=> 
----------------------
from django.db import models

# Create your models here.


class Promotions(models.Model):
    describtion = models.CharField(max_length=255)
    discount = models.FloatField()


class Collections(models.Model):
    title = models.CharField(max_length=255)
    featured_product = models.ForeignKey('Products',on_delete=models.SET_NULL, null=True, related_name='+')

    def __str__(self):
        return self.title 
    
    class Meta:
        ordering = ['title']

    


class Products (models.Model):
    slug = models.SlugField()
    sku = models.CharField(max_length=10,primary_key=True)
    title = models.CharField(max_length=255)
    describtion = models.TextField()
    unit_price = models.DecimalField(max_digits=10, decimal_places=2) 
    inventory = models.IntegerField()
    last_update = models.DateTimeField(auto_now=True)
    collections = models.ForeignKey(Collections,on_delete=models.PROTECT,related_name='products') # if want to delete Collections , Before must be delete Products .
    promotions = models.ManyToManyField(Promotions)

    def __str__(self) -> str:
        return self.title
    
    class Meta: 
        ordering = ['title']




class Customers(models.Model):
    MEMBERSHIP_BRONZE = 'B'
    MEMBERSHIP_SLIVER = 'S'
    MEMBERSHIP_GOLD = 'G'
    MEMBERSHIP_CHOICE = [
    ('MEMBERSHIP_BRONZE','Bronze'),
    ('MEMBERSHIP_SLIVER','Silver'),
    ('MEMBERSHIP_GOLD','Gold'),
    ]

    first_name = models.CharField(max_length=255)
    last_name = models.CharField(max_length=255)
    email = models.EmailField(unique=True)
    phone = models.IntegerField()
    brith_date = models.DateField(null=True)
    membership = models.CharField(max_length=17, choices=MEMBERSHIP_CHOICE, default=MEMBERSHIP_BRONZE)
    
    def __str__(self):
        return f"{self.first_name} {self.last_name }"


    class Meta:
        ordering = ['first_name', 'last_name']



class Order(models.Model):
    PAYMENT_STATUS_PENDING = 'P'
    PAYMENT_STATUS_COMPLETE = 'C'
    PAYMENT_STATUS_FAILD = 'F'
    PAYMENT_STATUS_CHOICE = [
        ('PAYMENT_STATUS_PENDING','P'),
        ('PAYMENT_STATUS_COMPLETE','C'),
        ('PAYMENT_STATUS_FAILD','F'),
    ]
    place_order = models.DateTimeField(auto_now_add=True)
    payment_status = models.CharField(
    max_length=23, choices=PAYMENT_STATUS_CHOICE, default=PAYMENT_STATUS_PENDING
    )

    Customers = models.ForeignKey(Customers,on_delete=models.PROTECT) #if accidently delete the Customers , we don't delete the order .

class OrderItems(models.Model):
    order = models.ForeignKey(Order,on_delete=models.PROTECT)
    Products = models.ForeignKey(Products,on_delete=models.PROTECT, related_name='orderItems')
    quentity = models.PositiveSmallIntegerField()
    unit_price = models.DecimalField(max_digits=6,decimal_places=2)

class Cart(models.Model):
    created_at = models.DateTimeField(auto_now_add=True)

class Address(models.Model):
    street = models.CharField(max_length=255)  # Corrected max_length
    city = models.CharField(max_length=255)  
    

    #one to one relationship
    Customers = models.OneToOneField(Customers,on_delete=models.CASCADE, primary_key=True ) 

class CartItem(models.Model):
    cart = models.ForeignKey(Cart,on_delete=models.CASCADE)
    Products = models.ForeignKey(Products,on_delete=models.CASCADE)
    quantitiy = models.PositiveSmallIntegerField()


---------------------------------
---------------------------------
store=>serializer.py=> 
---------------------------------
from decimal import Decimal
from rest_framework import serializers
from store.models import Products,Collections

class ProductSerializer(serializers.ModelSerializer):
    

    class Meta : 
        model = Products
        fields = ['title', 'price', 'collections','price_with_tax','inventory','describtion'] #first search fields form model , if not find . then search => price , collections, tax_with price

  
    price = serializers.DecimalField(max_digits=6, decimal_places=2, source='unit_price') #custome name price => comes from unit_prime -> product(model)
    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')

    def calculate_tax(self, product:Products):
        return product.unit_price * Decimal(1.1)



class CollectionsSerializer(serializers.ModelSerializer):
    products_count = serializers.IntegerField()  # Add this line

    class Meta: 
        model = Collections
        fields = ['id', 'title', 'products_count']

        







---------------------------------
---------------------------------
store:: urls.py=> 
-----------------
from django.urls import path
from store import views

urlpatterns = [
    path('product_list/',views.product_list,name='product_list' ),
    path('product/<str:sku>/', views.product_details, name='product'),
    path('collections/<int:pk>/', views.collection, name='collection-detials'), # serializer method - 4 .

    path('collections_list/',views.collection_list, name='collections'), 
    path('collection/<int:pk>/',views.collections_details,name='collection_details'),  # Add a trailing slash
 

]
---------------------------------
---------------------------------
store.views.py=> 
---------------------------------
from django.shortcuts import render
from django.http import HttpResponse


from rest_framework.decorators import api_view 
from rest_framework import generics
from rest_framework.response import Response #serializers to Json formater
from store.models import Products,Collections
from store.serializers import ProductSerializer,CollectionsSerializer
from django.shortcuts import get_object_or_404 #if object not found then raise error ...
from rest_framework.status import HTTP_200_OK,HTTP_201_CREATED,HTTP_204_NO_CONTENT
from django.db.models import Count



@api_view(['GET','POST'])
def product_list(request):
    if request.method == 'GET':
        products = Products.objects.select_related('collections')
        serializer = ProductSerializer(products, many=True, context={'request': request}) #connected with => name = contact-detiails
        return Response(serializer.data)
    

    elif request.method=='POST': #Create Product----------------------------------------
        serializer = ProductSerializer(data= request.data)
        serializer.is_valid(raise_exception=True) #if Error => then raise Error massage.
        serializer.save()
        return Response(serializer.data, status=HTTP_200_OK)



@api_view(['GET', 'PUT','DELETE'])
def product_details(request, sku): #Read/Update/Delete Product----------------------------------------
    product = get_object_or_404(Products, pk=sku)

    if request.method == 'GET':
        serializer = ProductSerializer(product)
        return Response(serializer.data)
    elif request.method == 'PUT': 
        serializer = ProductSerializer(product, data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data, status=HTTP_201_CREATED)
    elif request.method =='DELETE':
        if product.orderItems.count() > 0:  #aggregations-> count(), ORM query fn-> Count().
            return Response({"error": "product can't be delete cause in orderitem"},)
        product.delete()
        return Response(status=HTTP_204_NO_CONTENT)



@api_view()
def collection(request,pk):
    return Response('ok')

# --------------------------------collections-------------------------------------




@api_view(['GET','POST'])
def collection_list(request):
    if request.method == 'GET':
        query_set = Collections.objects.annotate(products_count=Count('products')).all()
        serializer = CollectionsSerializer(query_set,many=True)
        return Response(serializer.data,status=HTTP_200_OK)
    
    if request.method == "POST":
        serializer = CollectionsSerializer(data = request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data, status=HTTP_201_CREATED)




@api_view(['GET','PUT','DELETE'])
def collections_details(request, pk):

    collection = get_object_or_404(
        Collections.objects.annotate(products_count=Count('products')), pk=pk )

    if request.method == 'GET':
        product_count = collection.products_count
        serializer = CollectionsSerializer(collection)
        data = serializer.data
        data['product_count'] = product_count
        return Response(data, status=HTTP_200_OK)

    elif request.method == 'PUT':
        serializer = CollectionsSerializer(collection, data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data, status=HTTP_201_CREATED)

    elif request.method == 'DELETE':
        if collection.products.count() > 0:
            return Response({'error':"collections can't be deleted because order items are included"})
        collection.delete()
        return Response(status=HTTP_204_NO_CONTENT)



---------------------------------
---------------------------------
---------------------------------
---------------------------------
-------------------------------------------------------------------------------------------------------------
---------------------------------------RestAPi : APIView(CRUD)----------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
store::views.py=> 
-----------------
from django.shortcuts import render
from django.http import HttpResponse


from rest_framework.decorators import api_view 
from rest_framework import generics
from rest_framework.response import Response #serializers to Json formater
from store.models import Products,Collections
from store.serializers import ProductSerializer,CollectionsSerializer
from django.shortcuts import get_object_or_404 #if object not found then raise error ...
from rest_framework.status import HTTP_200_OK,HTTP_201_CREATED,HTTP_204_NO_CONTENT
from django.db.models import Count
from rest_framework.views import APIView



class Product_list(APIView):
    def get(self,request):
        products = Products.objects.select_related('collections')
        serializer = ProductSerializer(products, many=True) #connected with => name = contact-detiails
        return Response(serializer.data)
    
    def post(self,request):
        serializer = ProductSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data, status=HTTP_201_CREATED)




# @api_view(['GET', 'PUT','DELETE'])
class Product_details(APIView):
    def get(self,request, sku): #Read/Update/Delete Product----------------------------------------
        product = get_object_or_404(Products,pk=sku)
        serializer = ProductSerializer(product,many=False)
        return Response(serializer.data)
    
    def put(self,request,sku):
        product = get_object_or_404(Products,pk=sku)
        serializer = ProductSerializer(product, data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data, status=HTTP_201_CREATED)
    
    def delete(self,reqeust,sku):
        product = get_object_or_404(Products,pk=sku)
        if product.orderItems.count() > 0:  #aggregations-> count(), ORM query fn-> Count().
            return Response({"error": "product can't be delete cause in orderitem"},)
        product.delete()
        return Response(status=HTTP_204_NO_CONTENT)

------------------------------
------------------------------
store::urls.py=> 
------------------------------
from django.urls import path
from store import views

urlpatterns = [
    path('product_list/', views.Product_list.as_view(),name='product_list'),
    path('product/<str:sku>/', views.Product_details.as_view(), name='product_details'),
    path('collections/<int:pk>/', views.collection, name='collection-detials'), # serializer method - 4 .

    path('collections_list/',views.collection_list, name='collections'), 
    path('collection/<int:pk>/',views.collections_details,name='collection_details'),  # Add a trailing slash
 

]
------------------------------
------------------------------
srializer.py=> 
------------------------------
from decimal import Decimal
from rest_framework import serializers
from store.models import Products,Collections

class ProductSerializer(serializers.ModelSerializer):
    

    class Meta : 
        model = Products
        fields = ['title', 'price', 'collections','price_with_tax','inventory','describtion'] #first search fields form model , if not find . then search => price , collections, tax_with price

  
    price = serializers.DecimalField(max_digits=6, decimal_places=2, source='unit_price') #custome name price => comes from unit_prime -> product(model)
    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')

    def calculate_tax(self, product:Products):
        return product.unit_price * Decimal(1.1)



class CollectionsSerializer(serializers.ModelSerializer):
    products_count = serializers.IntegerField()  # Add this line

    class Meta: 
        model = Collections
        fields = ['id', 'title', 'products_count']

        







------------------------------
------------------------------
store::model.py=> 
------------------------------
from django.db import models

# Create your models here.


class Promotions(models.Model):
    describtion = models.CharField(max_length=255)
    discount = models.FloatField()


class Collections(models.Model):
    title = models.CharField(max_length=255)
    featured_product = models.ForeignKey('Products',on_delete=models.SET_NULL, null=True, related_name='+')

    def __str__(self):
        return self.title 
    
    class Meta:
        ordering = ['title']

    


class Products (models.Model):
    slug = models.SlugField()
    sku = models.CharField(max_length=10,primary_key=True)
    title = models.CharField(max_length=255)
    describtion = models.TextField()
    unit_price = models.DecimalField(max_digits=10, decimal_places=2) 
    inventory = models.IntegerField()
    last_update = models.DateTimeField(auto_now=True)
    collections = models.ForeignKey(Collections,on_delete=models.PROTECT,related_name='products') # if want to delete Collections , Before must be delete Products .
    promotions = models.ManyToManyField(Promotions)

    def __str__(self) -> str:
        return self.title
    
    class Meta: 
        ordering = ['title']




class Customers(models.Model):
    MEMBERSHIP_BRONZE = 'B'
    MEMBERSHIP_SLIVER = 'S'
    MEMBERSHIP_GOLD = 'G'
    MEMBERSHIP_CHOICE = [
    ('MEMBERSHIP_BRONZE','Bronze'),
    ('MEMBERSHIP_SLIVER','Silver'),
    ('MEMBERSHIP_GOLD','Gold'),
    ]

    first_name = models.CharField(max_length=255)
    last_name = models.CharField(max_length=255)
    email = models.EmailField(unique=True)
    phone = models.IntegerField()
    brith_date = models.DateField(null=True)
    membership = models.CharField(max_length=17, choices=MEMBERSHIP_CHOICE, default=MEMBERSHIP_BRONZE)
    
    def __str__(self):
        return f"{self.first_name} {self.last_name }"


    class Meta:
        ordering = ['first_name', 'last_name']



class Order(models.Model):
    PAYMENT_STATUS_PENDING = 'P'
    PAYMENT_STATUS_COMPLETE = 'C'
    PAYMENT_STATUS_FAILD = 'F'
    PAYMENT_STATUS_CHOICE = [
        ('PAYMENT_STATUS_PENDING','P'),
        ('PAYMENT_STATUS_COMPLETE','C'),
        ('PAYMENT_STATUS_FAILD','F'),
    ]
    place_order = models.DateTimeField(auto_now_add=True)
    payment_status = models.CharField(
    max_length=23, choices=PAYMENT_STATUS_CHOICE, default=PAYMENT_STATUS_PENDING
    )

    Customers = models.ForeignKey(Customers,on_delete=models.PROTECT) #if accidently delete the Customers , we don't delete the order .

class OrderItems(models.Model):
    order = models.ForeignKey(Order,on_delete=models.PROTECT)
    Products = models.ForeignKey(Products,on_delete=models.PROTECT, related_name='orderItems')
    quentity = models.PositiveSmallIntegerField()
    unit_price = models.DecimalField(max_digits=6,decimal_places=2)

class Cart(models.Model):
    created_at = models.DateTimeField(auto_now_add=True)

class Address(models.Model):
    street = models.CharField(max_length=255)  # Corrected max_length
    city = models.CharField(max_length=255)  
    

    #one to one relationship
    Customers = models.OneToOneField(Customers,on_delete=models.CASCADE, primary_key=True ) 

class CartItem(models.Model):
    cart = models.ForeignKey(Cart,on_delete=models.CASCADE)
    Products = models.ForeignKey(Products,on_delete=models.CASCADE)
    quantitiy = models.PositiveSmallIntegerField()
------------------------------
-------------------------------------------------------------------------------------------------------------
-------------------------------------Class Base Crud:generics()------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------


======================
store::urls.py=> 
======================
from django.urls import path
from store import views

urlpatterns = [
    path('product_list/', views.Product_list.as_view(),name='product_list'),
    path('product/<str:sku>/', views.Product_details.as_view(), name='product_details'),
    path('collections/<int:pk>/', views.collection, name='collection-detials'), # serializer method - 4 .

    path('collections_list/',views.Collection_list.as_view(), name='collections'), 
    path('collection/<int:pk>/',views.Collections_details.as_view(),name='collection_details'),  # Add a trailing slash
 

]
======================
======================

store::views.py=> 
-----------------------------
from django.shortcuts import render
from django.http import HttpResponse


from rest_framework.decorators import api_view 
from rest_framework import generics
from rest_framework.response import Response #serializers to Json formater
from store.models import Products,Collections
from store.serializers import ProductSerializer,CollectionsSerializer
from django.shortcuts import get_object_or_404 #if object not found then raise error ...
from rest_framework.status import HTTP_200_OK,HTTP_201_CREATED,HTTP_204_NO_CONTENT
from django.db.models import Count
from rest_framework.views import APIView


from rest_framework.generics import ListCreateAPIView,RetrieveUpdateDestroyAPIView



class Product_list(ListCreateAPIView):
    queryset = Products.objects.select_related('collections')
    serializer_class = ProductSerializer

    def get_serializer_context(self): #for serializer extra variable /
        return {'request':self.request}




class Product_details(RetrieveUpdateDestroyAPIView):
        
        queryset = Products.objects.all()
        serializer_class = ProductSerializer
        lookup_field = 'sku' #****if get error for the primaryKey then fix the key name = 'whateverWeWant'

        def delete(self,reqeust,sku):
            product = get_object_or_404(Products,pk=sku)
            if product.orderItems.count() > 0:  #aggregations-> count(), ORM query fn-> Count().
                return Response({"error": "product can't be delete cause in orderitem"},)
            product.delete()
            return Response(status=HTTP_204_NO_CONTENT)



@api_view()
def collection(request,pk):
    return Response('ok')

# --------------------------------collections-------------------------------------



class Collection_list(ListCreateAPIView):
        
        queryset = Collections.objects.annotate(products_count=Count('products')).all()
        serializer_class = CollectionsSerializer







class Collections_details(RetrieveUpdateDestroyAPIView):

    queryset = Collections.objects.all()
    serializer_class = CollectionsSerializer

    def delete(self, request, pk):
        collection = get_object_or_404(Collections, pk=pk)
        if collection.products.count() > 0:  # Changed 'collection' to 'collection'
            return Response({'error': "collections can't be deleted because order items are included"})
        collection.delete()
        return Response(status=HTTP_204_NO_CONTENT)


-----------------------------
serializer.py=> 
-----------------------------
from decimal import Decimal
from rest_framework import serializers
from store.models import Products,Collections

class ProductSerializer(serializers.ModelSerializer):
    

    class Meta : 
        model = Products
        fields = ['title', 'price', 'collections','price_with_tax','inventory','describtion'] #first search fields form model , if not find . then search => price , collections, tax_with price

  
    price = serializers.DecimalField(max_digits=6, decimal_places=2, source='unit_price') #custome name price => comes from unit_prime -> product(model)
    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')

    def calculate_tax(self, product:Products):
        return product.unit_price * Decimal(1.1)



class CollectionsSerializer(serializers.ModelSerializer):
    products_count = serializers.IntegerField(read_only=True)  # Add this line

    class Meta: 
        model = Collections
        fields = ['id', 'title', 'products_count']


===================
store::models.py=> 
===================

from django.db import models

# Create your models here.


class Promotions(models.Model):
    describtion = models.CharField(max_length=255)
    discount = models.FloatField()


class Collections(models.Model):
    title = models.CharField(max_length=255)
    featured_product = models.ForeignKey('Products',on_delete=models.SET_NULL, null=True, related_name='+')

    def __str__(self):
        return self.title 
    
    class Meta:
        ordering = ['title']

    


class Products (models.Model):
    slug = models.SlugField()
    sku = models.CharField(max_length=10,primary_key=True)
    title = models.CharField(max_length=255)
    describtion = models.TextField()
    unit_price = models.DecimalField(max_digits=10, decimal_places=2) 
    inventory = models.IntegerField()
    last_update = models.DateTimeField(auto_now=True)
    collections = models.ForeignKey(Collections,on_delete=models.PROTECT,related_name='products') # if want to delete Collections , Before must be delete Products .
    promotions = models.ManyToManyField(Promotions)

    def __str__(self) -> str:
        return self.title
    
    class Meta: 
        ordering = ['title']




class Customers(models.Model):
    MEMBERSHIP_BRONZE = 'B'
    MEMBERSHIP_SLIVER = 'S'
    MEMBERSHIP_GOLD = 'G'
    MEMBERSHIP_CHOICE = [
    ('MEMBERSHIP_BRONZE','Bronze'),
    ('MEMBERSHIP_SLIVER','Silver'),
    ('MEMBERSHIP_GOLD','Gold'),
    ]

    first_name = models.CharField(max_length=255)
    last_name = models.CharField(max_length=255)
    email = models.EmailField(unique=True)
    phone = models.IntegerField()
    brith_date = models.DateField(null=True)
    membership = models.CharField(max_length=17, choices=MEMBERSHIP_CHOICE, default=MEMBERSHIP_BRONZE)
    
    def __str__(self):
        return f"{self.first_name} {self.last_name }"


    class Meta:
        ordering = ['first_name', 'last_name']



class Order(models.Model):
    PAYMENT_STATUS_PENDING = 'P'
    PAYMENT_STATUS_COMPLETE = 'C'
    PAYMENT_STATUS_FAILD = 'F'
    PAYMENT_STATUS_CHOICE = [
        ('PAYMENT_STATUS_PENDING','P'),
        ('PAYMENT_STATUS_COMPLETE','C'),
        ('PAYMENT_STATUS_FAILD','F'),
    ]
    place_order = models.DateTimeField(auto_now_add=True)
    payment_status = models.CharField(
    max_length=23, choices=PAYMENT_STATUS_CHOICE, default=PAYMENT_STATUS_PENDING
    )

    Customers = models.ForeignKey(Customers,on_delete=models.PROTECT) #if accidently delete the Customers , we don't delete the order .

class OrderItems(models.Model):
    order = models.ForeignKey(Order,on_delete=models.PROTECT)
    Products = models.ForeignKey(Products,on_delete=models.PROTECT, related_name='orderItems')
    quentity = models.PositiveSmallIntegerField()
    unit_price = models.DecimalField(max_digits=6,decimal_places=2)

class Cart(models.Model):
    created_at = models.DateTimeField(auto_now_add=True)

class Address(models.Model):
    street = models.CharField(max_length=255)  # Corrected max_length
    city = models.CharField(max_length=255)  
    

    #one to one relationship
    Customers = models.OneToOneField(Customers,on_delete=models.CASCADE, primary_key=True ) 

class CartItem(models.Model):
    cart = models.ForeignKey(Cart,on_delete=models.CASCADE)
    Products = models.ForeignKey(Products,on_delete=models.CASCADE)
    quantitiy = models.PositiveSmallIntegerField()

        







-------------------------------------------------------------------------------------------------------------
-------------------------------------ViewSet:Crud in shortly.------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
***********while using ViewSet=>  if import store.views in urls.py for multiple times in main_project_urls or
 sub-app_urls together,like store.views(), then get error .and 
urls of api/ends/ not working ..... must be use app name > app_name='api'. 
-------------------------------------------------------------------------
store::urls.py=> 
--------------------------


from django.urls import path
from store import views

from rest_framework.routers import SimpleRouter,DefaultRouter #default router show the api endpoint urls.

app_name = 'store'


router = DefaultRouter()
router.register(r'product', views.ProductViewSet) 
router.register(r'collection', views.CollectionViewSet) 
urlpatterns = [] + router.urls


# from django.urls import path
# from store import views

# urlpatterns = [
#     path('product/', views.ProductViewSet.as_view({'get': 'list', 'post': 'create'}), name='product-list'),
#     path('product/<str:pk>/', views.ProductViewSet.as_view({'get': 'retrieve', 'put': 'update', 'delete': 'destroy'}), name='product-detail'),
#     path('collections/', views.CollectionViewSet.as_view({'get': 'list', 'post': 'create'}), name='collection-list'),
#     path('collections/<int:pk>/', views.CollectionViewSet.as_view({'get': 'retrieve', 'put': 'update', 'delete': 'destroy'}), name='collection-detail'),
# ]


--------------------------
--------------------------
store::views.py=> 
--------------------------
--------------------------
from django.shortcuts import render
from django.http import HttpResponse


from rest_framework.decorators import api_view 
from rest_framework import generics
from rest_framework.response import Response #serializers to Json formater
from store.models import Products,Collections,OrderItems
from store.serializers import ProductSerializer,CollectionsSerializer
from django.shortcuts import get_object_or_404 #if object not found then raise error ...
from rest_framework.status import HTTP_200_OK,HTTP_201_CREATED,HTTP_204_NO_CONTENT
from django.db.models import Count
from rest_framework.views import APIView



from rest_framework.generics import ListCreateAPIView,RetrieveUpdateDestroyAPIView
from rest_framework.viewsets import ModelViewSet



class ProductViewSet(ModelViewSet):
    queryset = Products.objects.select_related('collections')
    serializer_class = ProductSerializer

    def get_serializer_context(self): #for serializer extra variable /
        return {'request':self.request}
    
    def destroy(self, request, *args, **kwargs):
          if OrderItems.objects.filter(product__id=kwargs['pk']).count() > 0:  #aggregations-> count(), ORM query fn-> Count().
                return Response({"error": "product can't be delete cause in orderitem"},)
         
          return super().destroy(request, *args, **kwargs)
  




# --------------------------------collections-------------------------------------



class CollectionViewSet(ModelViewSet):
        
        queryset = Collections.objects.annotate(products_count=Count('products')).all()
        serializer_class = CollectionsSerializer

        def destroy(self, request, *args, **kwargs):
             if OrderItems.products.filter(product__id=kwargs['pk']).count() > 0:  # Changed 'collection' to 'collection'
                return Response({'error': "collections can't be deleted because order items are included"})
             
             return super().destroy(request, *args, **kwargs)
       




--------------------------
--------------------------
serializer.py=> 
--------------------------
--------------------------
from decimal import Decimal
from rest_framework import serializers
from store.models import Products,Collections

class ProductSerializer(serializers.ModelSerializer):
    

    class Meta : 
        model = Products
        fields = ['title', 'price', 'collections','price_with_tax','inventory','describtion'] #first search fields form model , if not find . then search => price , collections, tax_with price

  
    price = serializers.DecimalField(max_digits=6, decimal_places=2, source='unit_price') #custome name price => comes from unit_prime -> product(model)
    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')

    def calculate_tax(self, product:Products):
        return product.unit_price * Decimal(1.1)



class CollectionsSerializer(serializers.ModelSerializer):
    products_count = serializers.IntegerField(read_only=True)  # Add this line

    class Meta: 
        model = Collections
        fields = ['id', 'title', 'products_count']

        







--------------------------
--------------------------
models.py=> 
--------------------------
--------------------------
from django.db import models

# Create your models here.


class Promotions(models.Model):
    describtion = models.CharField(max_length=255)
    discount = models.FloatField()


class Collections(models.Model):
    title = models.CharField(max_length=255)
    featured_product = models.ForeignKey('Products',on_delete=models.SET_NULL, null=True, related_name='+')

    def __str__(self):
        return self.title 
    
    class Meta:
        ordering = ['title']

    


class Products (models.Model):
    slug = models.SlugField()
    sku = models.CharField(max_length=10,primary_key=True)
    title = models.CharField(max_length=255)
    describtion = models.TextField()
    unit_price = models.DecimalField(max_digits=10, decimal_places=2) 
    inventory = models.IntegerField()
    last_update = models.DateTimeField(auto_now=True)
    collections = models.ForeignKey(Collections,on_delete=models.PROTECT,related_name='products') # if want to delete Collections , Before must be delete Products .
    promotions = models.ManyToManyField(Promotions)

    def __str__(self) -> str:
        return self.title
    
    class Meta: 
        ordering = ['title']




class Customers(models.Model):
    MEMBERSHIP_BRONZE = 'B'
    MEMBERSHIP_SLIVER = 'S'
    MEMBERSHIP_GOLD = 'G'
    MEMBERSHIP_CHOICE = [
    ('MEMBERSHIP_BRONZE','Bronze'),
    ('MEMBERSHIP_SLIVER','Silver'),
    ('MEMBERSHIP_GOLD','Gold'),
    ]

    first_name = models.CharField(max_length=255)
    last_name = models.CharField(max_length=255)
    email = models.EmailField(unique=True)
    phone = models.IntegerField()
    brith_date = models.DateField(null=True)
    membership = models.CharField(max_length=17, choices=MEMBERSHIP_CHOICE, default=MEMBERSHIP_BRONZE)
    
    def __str__(self):
        return f"{self.first_name} {self.last_name }"


    class Meta:
        ordering = ['first_name', 'last_name']



class Order(models.Model):
    PAYMENT_STATUS_PENDING = 'P'
    PAYMENT_STATUS_COMPLETE = 'C'
    PAYMENT_STATUS_FAILD = 'F'
    PAYMENT_STATUS_CHOICE = [
        ('PAYMENT_STATUS_PENDING','P'),
        ('PAYMENT_STATUS_COMPLETE','C'),
        ('PAYMENT_STATUS_FAILD','F'),
    ]
    place_order = models.DateTimeField(auto_now_add=True)
    payment_status = models.CharField(
    max_length=23, choices=PAYMENT_STATUS_CHOICE, default=PAYMENT_STATUS_PENDING
    )

    Customers = models.ForeignKey(Customers,on_delete=models.PROTECT) #if accidently delete the Customers , we don't delete the order .

class OrderItems(models.Model):
    order = models.ForeignKey(Order,on_delete=models.PROTECT)
    Products = models.ForeignKey(Products,on_delete=models.PROTECT, related_name='orderItems')
    quentity = models.PositiveSmallIntegerField()
    unit_price = models.DecimalField(max_digits=6,decimal_places=2)

class Cart(models.Model):
    created_at = models.DateTimeField(auto_now_add=True)

class Address(models.Model):
    street = models.CharField(max_length=255)  # Corrected max_length
    city = models.CharField(max_length=255)  
    

    #one to one relationship
    Customers = models.OneToOneField(Customers,on_delete=models.CASCADE, primary_key=True ) 

class CartItem(models.Model):
    cart = models.ForeignKey(Cart,on_delete=models.CASCADE)
    Products = models.ForeignKey(Products,on_delete=models.CASCADE)
    quantitiy = models.PositiveSmallIntegerField()
--------------------------
--------------------------

-------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
--------------------------------------Reviews Section: download nested-router first-----------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
---------------------------------https://github.com/alanjds/drf-nested-routers-------------- ----------------
no need to setup in settings.py=> 
-------------------------------------------------------------------------------------------------------------
Store::models.py=> 
----------------------
from django.db import models

# Create your models here.


class Promotions(models.Model):
    describtion = models.CharField(max_length=255)
    discount = models.FloatField()


class Collections(models.Model):
    title = models.CharField(max_length=255)
    featured_product = models.ForeignKey('Products',on_delete=models.SET_NULL, null=True, related_name='+')

    def __str__(self):
        return self.title 
    
    class Meta:
        ordering = ['title']

    


class Products (models.Model):
    slug = models.SlugField()
    sku = models.CharField(max_length=10,primary_key=True)
    title = models.CharField(max_length=255)
    describtion = models.TextField()
    unit_price = models.DecimalField(max_digits=10, decimal_places=2) 
    inventory = models.IntegerField()
    last_update = models.DateTimeField(auto_now=True)
    collections = models.ForeignKey(Collections,on_delete=models.PROTECT,related_name='products') # if want to delete Collections , Before must be delete Products .
    promotions = models.ManyToManyField(Promotions)

    def __str__(self) -> str:
        return self.title
    
    class Meta: 
        ordering = ['title']




class Customers(models.Model):
    MEMBERSHIP_BRONZE = 'B'
    MEMBERSHIP_SLIVER = 'S'
    MEMBERSHIP_GOLD = 'G'
    MEMBERSHIP_CHOICE = [
    ('MEMBERSHIP_BRONZE','Bronze'),
    ('MEMBERSHIP_SLIVER','Silver'),
    ('MEMBERSHIP_GOLD','Gold'),
    ]

    first_name = models.CharField(max_length=255)
    last_name = models.CharField(max_length=255)
    email = models.EmailField(unique=True)
    phone = models.IntegerField()
    brith_date = models.DateField(null=True)
    membership = models.CharField(max_length=17, choices=MEMBERSHIP_CHOICE, default=MEMBERSHIP_BRONZE)
    
    def __str__(self):
        return f"{self.first_name} {self.last_name }"


    class Meta:
        ordering = ['first_name', 'last_name']



class Order(models.Model):
    PAYMENT_STATUS_PENDING = 'P'
    PAYMENT_STATUS_COMPLETE = 'C'
    PAYMENT_STATUS_FAILD = 'F'
    PAYMENT_STATUS_CHOICE = [
        ('PAYMENT_STATUS_PENDING','P'),
        ('PAYMENT_STATUS_COMPLETE','C'),
        ('PAYMENT_STATUS_FAILD','F'),
    ]
    place_order = models.DateTimeField(auto_now_add=True)
    payment_status = models.CharField(
    max_length=23, choices=PAYMENT_STATUS_CHOICE, default=PAYMENT_STATUS_PENDING
    )

    Customers = models.ForeignKey(Customers,on_delete=models.PROTECT) #if accidently delete the Customers , we don't delete the order .

class OrderItems(models.Model):
    order = models.ForeignKey(Order,on_delete=models.PROTECT)
    Products = models.ForeignKey(Products,on_delete=models.PROTECT, related_name='orderItems')
    quentity = models.PositiveSmallIntegerField()
    unit_price = models.DecimalField(max_digits=6,decimal_places=2)

class Cart(models.Model):
    created_at = models.DateTimeField(auto_now_add=True)

class Address(models.Model):
    street = models.CharField(max_length=255)  # Corrected max_length
    city = models.CharField(max_length=255)  
    

    #one to one relationship
    Customers = models.OneToOneField(Customers,on_delete=models.CASCADE, primary_key=True ) 

class CartItem(models.Model):
    cart = models.ForeignKey(Cart,on_delete=models.CASCADE)
    Products = models.ForeignKey(Products,on_delete=models.CASCADE)
    quantitiy = models.PositiveSmallIntegerField()



class Review(models.Model):
    product = models.ForeignKey(Products,on_delete=models.CASCADE, related_name='review')
    name = models.CharField(max_length=255)
    describtion = models.TextField()
    date = models.DateField(auto_now_add=True)

-------------------------------
-------------------------------
store::serializer.py->
-------------------------------
-------------------------------
from decimal import Decimal
from rest_framework import serializers
from store.models import Products,Collections,Review

class ProductSerializer(serializers.ModelSerializer):
    

    class Meta : 
        model = Products
        fields = ['title', 'price', 'collections','price_with_tax','inventory','describtion'] #first search fields form model , if not find . then search => price , collections, tax_with price

  
    price = serializers.DecimalField(max_digits=6, decimal_places=2, source='unit_price') #custome name price => comes from unit_prime -> product(model)
    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')

    def calculate_tax(self, product:Products):
        return product.unit_price * Decimal(1.1)



class CollectionsSerializer(serializers.ModelSerializer):
    products_count = serializers.IntegerField(read_only=True)  # Add this line

    class Meta: 
        model = Collections
        fields = ['id', 'title', 'products_count']

        


class ReviewSerializer(serializers.ModelSerializer):

    class Meta: 
        model = Review
        fields = ['id', 'date','name', 'describtion','product']

    #Receive data from context method form views.Reveiws (product_id, reviews_also )
    def create(self,validated_data):
        product_id = self.context ['product_id']
        return Review.objects.create(product_id=product_id,**validated_data)


-------------------------------
-------------------------------
store::views.py=> 
-------------------------------
-------------------------------
from django.shortcuts import render
from django.http import HttpResponse


from rest_framework.decorators import api_view 
from rest_framework import generics
from rest_framework.response import Response #serializers to Json formater
from store.models import Products,Collections,OrderItems,Review
from store.serializers import ProductSerializer,CollectionsSerializer,ReviewSerializer
from django.shortcuts import get_object_or_404 #if object not found then raise error ...
from rest_framework.status import HTTP_200_OK,HTTP_201_CREATED,HTTP_204_NO_CONTENT
from django.db.models import Count
from rest_framework.views import APIView



from rest_framework.generics import ListCreateAPIView,RetrieveUpdateDestroyAPIView
from rest_framework.viewsets import ModelViewSet



class ProductViewSet(ModelViewSet):
    queryset = Products.objects.select_related('collections')
    serializer_class = ProductSerializer

    def get_serializer_context(self): #for serializer extra variable /
        return {'request':self.request}
    
    def destroy(self, request, *args, **kwargs):
          if OrderItems.objects.filter(product__id=kwargs['pk']).count() > 0:  #aggregations-> count(), ORM query fn-> Count().
                return Response({"error": "product can't be delete cause in orderitem"},)
         
          return super().destroy(request, *args, **kwargs)
  




# --------------------------------collections-------------------------------------



class CollectionViewSet(ModelViewSet):
        
        queryset = Collections.objects.annotate(products_count=Count('products')).all()
        serializer_class = CollectionsSerializer

        def destroy(self, request, *args, **kwargs):
             if OrderItems.products.filter(product__id=kwargs['pk']).count() > 0:  # Changed 'collection' to 'collection'
                return Response({'error': "collections can't be deleted because order items are included"})
             
             return super().destroy(request, *args, **kwargs)
       

class ReviewViewSet(ModelViewSet):
     #cutom query : cz reviews show for every product : filter review for indivisual products.
     def get_queryset(self):
         return Review.objects.filter(product_id =self.kwargs['product_pk'])
     

     #use this method for => send data to Review serializer
     def get_context_data(self) :
         return {'product_id':self.kwargs['product_pk']}
     
     
     serializer_class = ReviewSerializer



-------------------------------
-------------------------------
urls.py=> 
-------------------------------
-------------------------------
from django.urls import path
from store import views
#default router show the api endpoint urls.
from rest_framework_nested import routers


app_name = 'store'


router = routers.DefaultRouter()
router.register(r'product', views.ProductViewSet)
router.register(r'collection', views.CollectionViewSet)

product_router = routers.NestedDefaultRouter(router, r'product', lookup='product')
product_router.register(r'review', views.ReviewViewSet, basename='product-reviews')

urlpatterns = [] + router.urls + product_router.urls



-------------------------------------------------------------------------------------------------------------
----------------------------------------filter data (urls) ---------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
urls.py=> 
==========
from django.urls import path
from store import views
#default router show the api endpoint urls.
from rest_framework_nested import routers


app_name = 'store'


router = routers.DefaultRouter()
router.register(r'product', views.ProductViewSet, basename='product') #assertions baseName error that's why add base name
router.register(r'collection', views.CollectionViewSet)

product_router = routers.NestedDefaultRouter(router, r'product', lookup='product')
product_router.register(r'review', views.ReviewViewSet, basename='product-reviews')

urlpatterns = [] + router.urls + product_router.urls



--------------------------------
views.py-> 
---------------------
from django.shortcuts import render
from django.http import HttpResponse


from rest_framework.decorators import api_view 
from rest_framework import generics
from rest_framework.response import Response #serializers to Json formater
from store.models import Products,Collections,OrderItems,Review
from store.serializers import ProductSerializer,CollectionsSerializer,ReviewSerializer
from django.shortcuts import get_object_or_404 #if object not found then raise error ...
from rest_framework.status import HTTP_200_OK,HTTP_201_CREATED,HTTP_204_NO_CONTENT
from django.db.models import Count
from rest_framework.views import APIView



from rest_framework.generics import ListCreateAPIView,RetrieveUpdateDestroyAPIView
from rest_framework.viewsets import ModelViewSet



class ProductViewSet(ModelViewSet):

    #if use custom query then get error for the base name . parent router should be add the base_name cz query 
    #cz query run according to the basename ...
    
    serializer_class = ProductSerializer

    #for filter product according to collections id , need custom query: 
    def get_queryset(self):
        queryset = Products.objects.all()

        #self.reqeust take value form user;
        #  query_param[] use in url for Sqlquery and return query but it's not work properly, that's why use query.get().
        collection_id = self.request.query_params.get('collection_id') #MultiValueDictKeyError at /store/product : solve the error use query.get()

        if collection_id is not None: 
             queryset = queryset.filter(collections_id=collection_id) #first collections varibale add extra -> s (revers word avoiding)
       
        return queryset


    def get_serializer_context(self): #for serializer extra variable /
        return {'request':self.request}
    
    def destroy(self, request, *args, **kwargs):
          if OrderItems.objects.filter(product__id=kwargs['pk']).count() > 0:  #aggregations-> count(), ORM query fn-> Count().
                return Response({"error": "product can't be delete cause in orderitem"},)
         
          return super().destroy(request, *args, **kwargs)
  




# --------------------------------collections-------------------------------------



class CollectionViewSet(ModelViewSet):
        
        queryset = Collections.objects.annotate(products_count=Count('products')).all()
        serializer_class = CollectionsSerializer

        def destroy(self, request, *args, **kwargs):
             if OrderItems.products.filter(product__id=kwargs['pk']).count() > 0:  # Changed 'collection' to 'collection'
                return Response({'error': "collections can't be deleted because order items are included"})
             
             return super().destroy(request, *args, **kwargs)
       

class ReviewViewSet(ModelViewSet):
     #cutom query : cz reviews show for every product : filter review for indivisual products.
     def get_queryset(self):
         return Review.objects.filter(product_id =self.kwargs['product_pk'])
     

     #use this method for => send data to Review serializer
     def get_context_data(self) :
         return {'product_id':self.kwargs['product_pk']}
     
     
     serializer_class = ReviewSerializer



--------------------------------



now filter product according to collections_id => http://127.0.0.1:8000/store/product/?collections_id=1
-------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
--------------------------------------Add Django-filter: unit_price(filter) product-----------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
create a filte in store app -> filters.py => 
-------------------------------------------
from django_filters.rest_framework import FilterSet 
from store.models import Products

class ProductFilter(FilterSet):

    class Meta: 

        model = Products 
        
        fields = {
            'collections_id': ['exact'],
            'unit_price' : ['gt','lt']
        }
------------------------------------------------
------------------------------------------------
then import in store::views.py => 
------------------------------------------------
------------------------------------------------
from django.shortcuts import render
from django.http import HttpResponse


from rest_framework.decorators import api_view 
from rest_framework import generics
from rest_framework.response import Response #serializers to Json formater
from store.models import Products,Collections,OrderItems,Review
from store.serializers import ProductSerializer,CollectionsSerializer,ReviewSerializer
from django.shortcuts import get_object_or_404 #if object not found then raise error ...
from rest_framework.status import HTTP_200_OK,HTTP_201_CREATED,HTTP_204_NO_CONTENT
from django.db.models import Count
from rest_framework.views import APIView



from rest_framework.generics import ListCreateAPIView,RetrieveUpdateDestroyAPIView
from rest_framework.viewsets import ModelViewSet
from django_filters.rest_framework import DjangoFilterBackend # filter easyly with any Db.coloumn like price ...
from .filters import ProductFilter 

class ProductViewSet(ModelViewSet):

    queryset = Products.objects.all()
    serializer_class = ProductSerializer

    #for filter: =>-------------------------
    filter_backends = [DjangoFilterBackend]
    # filterset_fields = ['collections_id']
    filterset_class = ProductFilter



    def get_serializer_context(self): #for serializer extra variable /mehtod to send to serializer
        return {'request':self.request}
    
    def destroy(self, request, *args, **kwargs):
          if OrderItems.objects.filter(product__id=kwargs['pk']).count() > 0:  #aggregations-> count(), ORM query fn-> Count().
                return Response({"error": "product can't be delete cause in orderitem"},)
         
          return super().destroy(request, *args, **kwargs)
  




# --------------------------------collections-------------------------------------



class CollectionViewSet(ModelViewSet):
        
        queryset = Collections.objects.annotate(products_count=Count('products')).all()
        serializer_class = CollectionsSerializer

        def destroy(self, request, *args, **kwargs):
             if OrderItems.products.filter(product__id=kwargs['pk']).count() > 0:  # Changed 'collection' to 'collection'
                return Response({'error': "collections can't be deleted because order items are included"})
             
             return super().destroy(request, *args, **kwargs)
       

class ReviewViewSet(ModelViewSet):
     #cutom query : cz reviews show for every product : filter review for indivisual products.
     def get_queryset(self):
         return Review.objects.filter(product_id =self.kwargs['product_pk'])
     

     #use this method for => send data to Review serializer
     def get_context_data(self) :
         return {'product_id':self.kwargs['product_pk']}
     
     
     serializer_class = ReviewSerializer



------------------------------------------------
------------------------------------------------
------------------------------------------------
-------------------------------------------------------------------------------------------------------------
--------------------------------------------seraching , Sorting : filter-----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
store::views.py=> 
------------------------------------------------

ffrom django.db import models

# Create your models here.


class Promotions(models.Model):
    describtion = models.CharField(max_length=255)
    discount = models.FloatField()


class Collections(models.Model):
    title = models.CharField(max_length=255)
    featured_product = models.ForeignKey('Products',on_delete=models.SET_NULL, null=True, related_name='+')

    def __str__(self):
        return self.title 
    
    class Meta:
        ordering = ['title']

    


class Products (models.Model):
    slug = models.SlugField()
    sku = models.CharField(max_length=10,primary_key=True)
    title = models.CharField(max_length=255)
    describtion = models.TextField()
    unit_price = models.DecimalField(max_digits=10, decimal_places=2) 
    inventory = models.IntegerField()
    last_update = models.DateTimeField(auto_now=True)
    collections = models.ForeignKey(Collections,on_delete=models.PROTECT,related_name='products') # if want to delete Collections , Before must be delete Products .
    promotions = models.ManyToManyField(Promotions)

    def __str__(self) -> str:
        return self.title
    
    class Meta: 
        ordering = ['title']




class Customers(models.Model):
    MEMBERSHIP_BRONZE = 'B'
    MEMBERSHIP_SLIVER = 'S'
    MEMBERSHIP_GOLD = 'G'
    MEMBERSHIP_CHOICE = [
    ('MEMBERSHIP_BRONZE','Bronze'),
    ('MEMBERSHIP_SLIVER','Silver'),
    ('MEMBERSHIP_GOLD','Gold'),
    ]

    first_name = models.CharField(max_length=255)
    last_name = models.CharField(max_length=255)
    email = models.EmailField(unique=True)
    phone = models.IntegerField()
    brith_date = models.DateField(null=True)
    membership = models.CharField(max_length=17, choices=MEMBERSHIP_CHOICE, default=MEMBERSHIP_BRONZE)
    
    def __str__(self):
        return f"{self.first_name} {self.last_name }"


    class Meta:
        ordering = ['first_name', 'last_name']



class Order(models.Model):
    PAYMENT_STATUS_PENDING = 'P'
    PAYMENT_STATUS_COMPLETE = 'C'
    PAYMENT_STATUS_FAILD = 'F'
    PAYMENT_STATUS_CHOICE = [
        ('PAYMENT_STATUS_PENDING','P'),
        ('PAYMENT_STATUS_COMPLETE','C'),
        ('PAYMENT_STATUS_FAILD','F'),
    ]
    place_order = models.DateTimeField(auto_now_add=True)
    payment_status = models.CharField(
    max_length=23, choices=PAYMENT_STATUS_CHOICE, default=PAYMENT_STATUS_PENDING
    )

    Customers = models.ForeignKey(Customers,on_delete=models.PROTECT) #if accidently delete the Customers , we don't delete the order .

class OrderItems(models.Model):
    order = models.ForeignKey(Order,on_delete=models.PROTECT)
    Products = models.ForeignKey(Products,on_delete=models.PROTECT, related_name='orderItems')
    quentity = models.PositiveSmallIntegerField()
    unit_price = models.DecimalField(max_digits=6,decimal_places=2)

class Cart(models.Model):
    created_at = models.DateTimeField(auto_now_add=True)

class Address(models.Model):
    street = models.CharField(max_length=255)  # Corrected max_length
    city = models.CharField(max_length=255)  
    

    #one to one relationship
    Customers = models.OneToOneField(Customers,on_delete=models.CASCADE, primary_key=True ) 

class CartItem(models.Model):
    cart = models.ForeignKey(Cart,on_delete=models.CASCADE)
    Products = models.ForeignKey(Products,on_delete=models.CASCADE)
    quantitiy = models.PositiveSmallIntegerField()



class Review(models.Model):
    product = models.ForeignKey(Products,on_delete=models.CASCADE, related_name='review')
    name = models.CharField(max_length=255)
    describtion = models.TextField()
    date = models.DateField(auto_now_add=True)

------------------------------------------------
------------------------------------------------
-------------------------------------------------------------------------------------------------------------
---------------------------------------Paginations----------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
settings.py => if we add in setting then no need to add in views.py => for product, collections. either use default paginations.
---------------
REST_FRAMEWORK = {
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 10,  # Set your desired page size here
}


-------------------
store::paginations.py=> 
-------------------
from rest_framework.pagination import PageNumberPagination

class DefaultPagination(PageNumberPagination):

    page_size = 10
-------------------
-------------------
store::views.py=> 
-----------------

from rest_framework.response import Response #serializers to Json formater
from store.models import Products,Collections,OrderItems,Review
from store.serializers import ProductSerializer,CollectionsSerializer,ReviewSerializer
from django.db.models import Count



from rest_framework.viewsets import ModelViewSet
from django_filters.rest_framework import DjangoFilterBackend# filter easyly with any Db.coloumn like price ...
from rest_framework.filters import SearchFilter,OrderingFilter # for search,sorting -> product 
from rest_framework.pagination import PageNumberPagination #paginations
from .filters import ProductFilter 
from store.paginations import DefaultPagination #cutom paginations.

class ProductViewSet(ModelViewSet):

    queryset = Products.objects.all()
    serializer_class = ProductSerializer

    #for filter: =>-------------------------
    filter_backends = [DjangoFilterBackend,SearchFilter,OrderingFilter]
    # pagination_class = PageNumberPagination
    pagination_class = DefaultPagination  #custom paginations
    # filterset_fields = ['collections_id']
    filterset_class = ProductFilter #import form custom file.
    search_fields  = ['title', 'describtion'] #search box working with those fields.
    ordering_fields = ['unit_price','last_update']



    def get_serializer_context(self): #for serializer extra variable /mehtod to send to serializer
        return {'request':self.request}
    
    def destroy(self, request, *args, **kwargs):
          if OrderItems.objects.filter(product__id=kwargs['pk']).count() > 0:  #aggregations-> count(), ORM query fn-> Count().
                return Response({"error": "product can't be delete cause in orderitem"},)
         
          return super().destroy(request, *args, **kwargs)
  




# --------------------------------collections-------------------------------------



class CollectionViewSet(ModelViewSet):
        
        queryset = Collections.objects.annotate(products_count=Count('products')).all()
        serializer_class = CollectionsSerializer

        def destroy(self, request, *args, **kwargs):
             if OrderItems.products.filter(product__id=kwargs['pk']).count() > 0:  # Changed 'collection' to 'collection'
                return Response({'error': "collections can't be deleted because order items are included"})
             
             return super().destroy(request, *args, **kwargs)
       

class ReviewViewSet(ModelViewSet):
     #cutom query : cz reviews show for every product : filter review for indivisual products.
     def get_queryset(self):
         return Review.objects.filter(product_id =self.kwargs['product_pk'])
     

     #use this method for => send data to Review serializer
     def get_context_data(self) :
         return {'product_id':self.kwargs['product_pk']}
     
     
     serializer_class = ReviewSerializer




-------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
---------------------------------***CartItem***-----------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
first update the models of => cart , cartItem, use uuid -> global unique identifiter for protecting from hacking.
then migrate . 


---------------------------
store::models.py=> 
------------------------
from django.db import models
from uuid import uuid4 #for generate cart unique number.

# Create your models here.


class Promotions(models.Model):
    describtion = models.CharField(max_length=255)
    discount = models.FloatField()


class Collections(models.Model):
    title = models.CharField(max_length=255)
    featured_product = models.ForeignKey('Products',on_delete=models.SET_NULL, null=True, related_name='+')

    def __str__(self):
        return self.title 
    
    class Meta:
        ordering = ['title']

    


class Products (models.Model):
    slug = models.SlugField()
    sku = models.CharField(max_length=10,primary_key=True)
    title = models.CharField(max_length=255)
    describtion = models.TextField()
    unit_price = models.DecimalField(max_digits=10, decimal_places=2) 
    inventory = models.IntegerField()
    last_update = models.DateTimeField(auto_now=True)
    collections = models.ForeignKey(Collections,on_delete=models.PROTECT,related_name='products') # if want to delete Collections , Before must be delete Products .
    promotions = models.ManyToManyField(Promotions)

    def __str__(self) -> str:
        return self.title
    
    class Meta: 
        ordering = ['title']




class Customers(models.Model):
    MEMBERSHIP_BRONZE = 'B'
    MEMBERSHIP_SLIVER = 'S'
    MEMBERSHIP_GOLD = 'G'
    MEMBERSHIP_CHOICE = [
    ('MEMBERSHIP_BRONZE','Bronze'),
    ('MEMBERSHIP_SLIVER','Silver'),
    ('MEMBERSHIP_GOLD','Gold'),
    ]

    first_name = models.CharField(max_length=255)
    last_name = models.CharField(max_length=255)
    email = models.EmailField(unique=True)
    phone = models.IntegerField()
    brith_date = models.DateField(null=True)
    membership = models.CharField(max_length=17, choices=MEMBERSHIP_CHOICE, default=MEMBERSHIP_BRONZE)
    
    def __str__(self):
        return f"{self.first_name} {self.last_name }"


    class Meta:
        ordering = ['first_name', 'last_name']



class Order(models.Model):
    PAYMENT_STATUS_PENDING = 'P'
    PAYMENT_STATUS_COMPLETE = 'C'
    PAYMENT_STATUS_FAILD = 'F'
    PAYMENT_STATUS_CHOICE = [
        ('PAYMENT_STATUS_PENDING','P'),
        ('PAYMENT_STATUS_COMPLETE','C'),
        ('PAYMENT_STATUS_FAILD','F'),
    ]
    place_order = models.DateTimeField(auto_now_add=True)
    payment_status = models.CharField(
    max_length=23, choices=PAYMENT_STATUS_CHOICE, default=PAYMENT_STATUS_PENDING
    )

    Customers = models.ForeignKey(Customers,on_delete=models.PROTECT) #if accidently delete the Customers , we don't delete the order .

class OrderItems(models.Model):
    order = models.ForeignKey(Order,on_delete=models.PROTECT)
    Products = models.ForeignKey(Products,on_delete=models.PROTECT, related_name='orderItems')
    quentity = models.PositiveSmallIntegerField()
    unit_price = models.DecimalField(max_digits=6,decimal_places=2)

class Cart(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid4)
    created_at = models.DateTimeField(auto_now_add=True)

class Address(models.Model):
    street = models.CharField(max_length=255)  # Corrected max_length
    city = models.CharField(max_length=255)  
    

    #one to one relationship
    Customers = models.OneToOneField(Customers,on_delete=models.CASCADE, primary_key=True ) 

class CartItem(models.Model):
    cart = models.ForeignKey(Cart,on_delete=models.CASCADE, related_name='items') #
    Products = models.ForeignKey(Products,on_delete=models.CASCADE)
    quantitiy = models.PositiveSmallIntegerField()

    unique_together = [['cart','products']] #for unique generated....



class Review(models.Model):
    product = models.ForeignKey(Products,on_delete=models.CASCADE, related_name='review')
    name = models.CharField(max_length=255)
    describtion = models.TextField()
    date = models.DateField(auto_now_add=True)
---------------------------------------------
---------------------------------------------
store::urls.py=> 
---------------------------------------------
from django.urls import path
from store import views
#default router show the api endpoint urls.
from rest_framework_nested import routers


app_name = 'store'


router = routers.DefaultRouter()
router.register(r'product', views.ProductViewSet, basename='product') #assertions baseName error that's why add base name
router.register(r'collection', views.CollectionViewSet)
router.register(r'cart',views.CartViewSet,basename='cart')

product_router = routers.NestedDefaultRouter(router, r'product', lookup='product')
product_router.register(r'review', views.ReviewViewSet, basename='product-reviews')

urlpatterns = [] + router.urls + product_router.urls
---------------------------------------------
---------------------------------------------
store::cart::serializer=> 
---------------------------------------------
from decimal import Decimal
from rest_framework import serializers
from store.models import Products,Collections,Review,Cart,CartItem

class ProductSerializer(serializers.ModelSerializer):
    

    class Meta : 
        model = Products
        fields = ['title', 'price', 'collections','price_with_tax','inventory','describtion'] #first search fields form model , if not find . then search => price , collections, tax_with price

  
    price = serializers.DecimalField(max_digits=6, decimal_places=2, source='unit_price') #custome name price => comes from unit_prime -> product(model)
    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')

    def calculate_tax(self, product:Products):
        return product.unit_price * Decimal(1.1)



class CollectionsSerializer(serializers.ModelSerializer):
    products_count = serializers.IntegerField(read_only=True)  # Add this line

    class Meta: 
        model = Collections
        fields = ['id', 'title', 'products_count']

        


class ReviewSerializer(serializers.ModelSerializer):

    class Meta: 
        model = Review
        fields = ['id', 'date','name', 'describtion','product']

    #Receive data from context method form views.Reveiws (product_id, reviews_also )
    def create(self,validated_data):
        product_id = self.context ['product_id']
        return Review.objects.create(product_id=product_id,**validated_data)

class CartSerializer(serializers.ModelSerializer):
    #fix required fields problem: 
    id = serializers.UUIDField(read_only=True)

    class Meta:
        model = Cart
        fields = ['id']
---------------------------------------------
---------------------------------------------
store::views.py=> 
---------------------------------------------

from rest_framework.response import Response #serializers to Json formater
from store.models import Products,Collections,OrderItems,Review,Cart,CartItem
from store.serializers import ProductSerializer,CollectionsSerializer,ReviewSerializer,CartSerializer
from django.db.models import Count



from rest_framework.viewsets import ModelViewSet
from django_filters.rest_framework import DjangoFilterBackend# filter easyly with any Db.coloumn like price ...
from rest_framework.filters import SearchFilter,OrderingFilter # for search,sorting -> product 
from rest_framework.pagination import PageNumberPagination #paginations
from .filters import ProductFilter 
from store.paginations import DefaultPagination #cutom paginations.

#import for cart:
from rest_framework.mixins import CreateModelMixin
from rest_framework.viewsets import GenericViewSet

class ProductViewSet(ModelViewSet):

    queryset = Products.objects.all()
    serializer_class = ProductSerializer

    #for filter: =>-------------------------
    filter_backends = [DjangoFilterBackend,SearchFilter,OrderingFilter]
    # pagination_class = PageNumberPagination
    pagination_class = DefaultPagination  #custom paginations
    # filterset_fields = ['collections_id']
    filterset_class = ProductFilter #import form custom file.
    search_fields  = ['title', 'describtion'] #search box working with those fields.
    ordering_fields = ['unit_price','last_update']



    def get_serializer_context(self): #for serializer extra variable /mehtod to send to serializer
        return {'request':self.request}
    
    def destroy(self, request, *args, **kwargs):
          if OrderItems.objects.filter(product__id=kwargs['pk']).count() > 0:  #aggregations-> count(), ORM query fn-> Count().
                return Response({"error": "product can't be delete cause in orderitem"},)
         
          return super().destroy(request, *args, **kwargs)
  




# --------------------------------collections-------------------------------------



class CollectionViewSet(ModelViewSet):
        
        queryset = Collections.objects.annotate(products_count=Count('products')).all()
        serializer_class = CollectionsSerializer

        def destroy(self, request, *args, **kwargs):
             if OrderItems.products.filter(product__id=kwargs['pk']).count() > 0:  # Changed 'collection' to 'collection'
                return Response({'error': "collections can't be deleted because order items are included"})
             
             return super().destroy(request, *args, **kwargs)
       

class ReviewViewSet(ModelViewSet):
     #cutom query : cz reviews show for every product : filter review for indivisual products.
     def get_queryset(self):
         return Review.objects.filter(product_id =self.kwargs['product_pk'])
     

     #use this method for => send data to Review serializer
     def get_context_data(self) :
         return {'product_id':self.kwargs['product_pk']}
     
     
     serializer_class = ReviewSerializer


class CartViewSet(CreateModelMixin,GenericViewSet):
     
     queryset = Cart.objects.all()
     serializer_class = CartSerializer



---------------------------------------------

-------------------------------------------------------------------------------------------------------------
----------------------------------------Cart with RestApi(Main Part)---------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
urls.py=> 
------------
from django.urls import path
from store import views
#default router show the api endpoint urls.
from rest_framework_nested import routers


app_name = 'store'


router = routers.DefaultRouter()
router.register(r'product', views.ProductViewSet, basename='product') #assertions baseName error that's why add base name
router.register(r'collection', views.CollectionViewSet)
router.register(r'cart',views.CartViewSet,basename='cart')

#for retrive reviews form product use => 
product_router = routers.NestedDefaultRouter(router, r'product', lookup='product')
product_router.register(r'review', views.ReviewViewSet, basename='product-reviews')

#for retrive cartItem form cart use=> 
cart_router = routers.NestedDefaultRouter(router, r'cart', lookup='cart') # send to cart_pk to CartItemViews.
cart_router.register(r'cartItem', views.CartItemViewSet, basename='cart-items') #basename has 2 route cart-item-detials/ cart-item-list #as nested routers

urlpatterns = [] + router.urls + product_router.urls + cart_router.urls 
---------------------------
---------------------------
views.py=> 
---------------------------
---------------------------

from rest_framework.response import Response #serializers to Json formater
from store.models import Products,Collections,OrderItems,Review,Cart,CartItem
from store.serializers import ProductSerializer,CollectionsSerializer,ReviewSerializer,CartSerializer,CartItemSerializer,AddCartItemSerializer
from django.db.models import Count



from rest_framework.viewsets import ModelViewSet
from django_filters.rest_framework import DjangoFilterBackend# filter easyly with any Db.coloumn like price ...
from rest_framework.filters import SearchFilter,OrderingFilter # for search,sorting -> product 
from rest_framework.pagination import PageNumberPagination #paginations
from .filters import ProductFilter 
from store.paginations import DefaultPagination #cutom paginations.

#import for cart:
from rest_framework.mixins import CreateModelMixin,RetrieveModelMixin,ListModelMixin,DestroyModelMixin
from rest_framework.viewsets import GenericViewSet

class ProductViewSet(ModelViewSet):

    queryset = Products.objects.all()
    serializer_class = ProductSerializer

    #for filter: =>-------------------------
    filter_backends = [DjangoFilterBackend,SearchFilter,OrderingFilter]
    # pagination_class = PageNumberPagination
    pagination_class = DefaultPagination  #custom paginations
    # filterset_fields = ['collections_id']
    filterset_class = ProductFilter #import form custom file.
    search_fields  = ['title', 'describtion'] #search box working with those fields.
    ordering_fields = ['unit_price','last_update']



    def get_serializer_context(self): #for serializer extra variable /mehtod to send to serializer
        return {'request':self.request}
    
    def destroy(self, request, *args, **kwargs):
          if OrderItems.objects.filter(product__id=kwargs['pk']).count() > 0:  #aggregations-> count(), ORM query fn-> Count().
                return Response({"error": "product can't be delete cause in orderitem"},)
         
          return super().destroy(request, *args, **kwargs)
  




# --------------------------------collections-------------------------------------



class CollectionViewSet(ModelViewSet):
        
        queryset = Collections.objects.annotate(products_count=Count('products')).all()
        serializer_class = CollectionsSerializer

        def destroy(self, request, *args, **kwargs):
             if OrderItems.products.filter(product__id=kwargs['pk']).count() > 0:  # Changed 'collection' to 'collection'
                return Response({'error': "collections can't be deleted because order items are included"})
             
             return super().destroy(request, *args, **kwargs)
       

class ReviewViewSet(ModelViewSet):
     #cutom query : cz reviews show for every product : filter review for indivisual products.
     def get_queryset(self):
         return Review.objects.filter(product_id =self.kwargs['product_pk'])
     

     #use this method for => send data to Review serializer
     def get_context_data(self) :
         return {'product_id':self.kwargs['product_pk']}
     
     
     serializer_class = ReviewSerializer


class CartViewSet(CreateModelMixin,RetrieveModelMixin,ListModelMixin,DestroyModelMixin,GenericViewSet):
     
    #  queryset = Cart.objects.all()
     queryset = Cart.objects.prefetch_related('items__product').all() #cart -> Fk-> CartItem(related_name=items), instide cartItem Fk-> Products(product) | optimize the query
     serializer_class = CartSerializer


#show single items of cart: 
class CartItemViewSet(ModelViewSet):
     serializer_class = CartItemSerializer 

   


     #need single cartItem hast cart_id column , so need cart_ID+ to catch  :
     def get_queryset(self):
          return CartItem.objects.\
                        filter(cart_id=self.kwargs['cart_pk']).\
                        select_related('product')


---------------------------
---------------------------
serializer.py=> 
---------------------------
---------------------------
from decimal import Decimal
from rest_framework import serializers
from store.models import Products,Collections,Review,Cart,CartItem

class ProductSerializer(serializers.ModelSerializer):
    

    class Meta : 
        model = Products
        fields = ['title', 'price', 'collections','price_with_tax','inventory','describtion'] #first search fields form model , if not find . then search => price , collections, tax_with price

  
    price = serializers.DecimalField(max_digits=6, decimal_places=2, source='unit_price') #custome name price => comes from unit_prime -> product(model)
    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')

    def calculate_tax(self, product:Products):
        return product.unit_price * Decimal(1.1)



class CollectionsSerializer(serializers.ModelSerializer):
    products_count = serializers.IntegerField(read_only=True)  # Add this line

    class Meta: 
        model = Collections
        fields = ['id', 'title', 'products_count']

        


class ReviewSerializer(serializers.ModelSerializer):

    class Meta: 
        model = Review
        fields = ['id', 'date','name', 'describtion','product']

    #Receive data from context method form views.Reveiws (product_id, reviews_also )
    def create(self,validated_data):
        product_id = self.context ['product_id']
        return Review.objects.create(product_id=product_id,**validated_data)




#Cart take cartItems from CartItem serializers (parent - cart , child - cartItem):----------------------------

class SimpleProductSerializer(serializers.ModelSerializer):

    class Meta:
        model = Products
        fields = ['pk', 'title','unit_price']


class CartItemSerializer(serializers.ModelSerializer):
    product = SimpleProductSerializer() 
    total_price = serializers.SerializerMethodField()

    def get_total_price(self, cart_item: CartItem):
        return cart_item.quantity * cart_item.product.unit_price

    class Meta:
        model = CartItem
        fields = ['id', 'product', 'quantity', 'total_price']


class AddCartItemSerializer(serializers.ModelSerializer):
    product_id = serializers.IntegerField()

    class Meta:
        model = CartItem 
        fields = ['id','product_id','quantity']

class CartSerializer(serializers.ModelSerializer):
    id = serializers.UUIDField(read_only=True)
    items = CartItemSerializer(many=True, )  # Set read_only=True
    total_price = serializers.SerializerMethodField()

    def get_total_price(self,cart:Cart):
        return sum([item.quantity * item.product.unit_price for item in cart.items.all()]) #most important Line.

    class Meta:
        model = Cart
        fields = ['id', 'items', 'total_price']





---------------------------
---------------------------
store::models.py=> 
---------------------------
---------------------------
from django.db import models
from uuid import uuid4 #for generate cart unique number.

# Create your models here.


class Promotions(models.Model):
    describtion = models.CharField(max_length=255)
    discount = models.FloatField()


class Collections(models.Model):
    title = models.CharField(max_length=255)
    featured_product = models.ForeignKey('Products',on_delete=models.SET_NULL, null=True, related_name='+')

    def __str__(self):
        return self.title 
    
    class Meta:
        ordering = ['title']

    


class Products (models.Model):
    slug = models.SlugField()
    sku = models.CharField(max_length=10,primary_key=True)
    title = models.CharField(max_length=255)
    describtion = models.TextField()
    unit_price = models.DecimalField(max_digits=10, decimal_places=2) 
    inventory = models.IntegerField()
    last_update = models.DateTimeField(auto_now=True)
    collections = models.ForeignKey(Collections,on_delete=models.PROTECT,related_name='products') # if want to delete Collections , Before must be delete Products .
    promotions = models.ManyToManyField(Promotions)

    def __str__(self) -> str:
        return self.title
    
    class Meta: 
        ordering = ['title']




class Customers(models.Model):
    MEMBERSHIP_BRONZE = 'B'
    MEMBERSHIP_SLIVER = 'S'
    MEMBERSHIP_GOLD = 'G'
    MEMBERSHIP_CHOICE = [
    ('MEMBERSHIP_BRONZE','Bronze'),
    ('MEMBERSHIP_SLIVER','Silver'),
    ('MEMBERSHIP_GOLD','Gold'),
    ]

    first_name = models.CharField(max_length=255)
    last_name = models.CharField(max_length=255)
    email = models.EmailField(unique=True)
    phone = models.IntegerField()
    brith_date = models.DateField(null=True)
    membership = models.CharField(max_length=17, choices=MEMBERSHIP_CHOICE, default=MEMBERSHIP_BRONZE)
    
    def __str__(self):
        return f"{self.first_name} {self.last_name }"


    class Meta:
        ordering = ['first_name', 'last_name']



class Order(models.Model):
    PAYMENT_STATUS_PENDING = 'P'
    PAYMENT_STATUS_COMPLETE = 'C'
    PAYMENT_STATUS_FAILD = 'F'
    PAYMENT_STATUS_CHOICE = [
        ('PAYMENT_STATUS_PENDING','P'),
        ('PAYMENT_STATUS_COMPLETE','C'),
        ('PAYMENT_STATUS_FAILD','F'),
    ]
    place_order = models.DateTimeField(auto_now_add=True)
    payment_status = models.CharField(
    max_length=23, choices=PAYMENT_STATUS_CHOICE, default=PAYMENT_STATUS_PENDING
    )

    Customers = models.ForeignKey(Customers,on_delete=models.PROTECT) #if accidently delete the Customers , we don't delete the order .

class OrderItems(models.Model):
    order = models.ForeignKey(Order,on_delete=models.PROTECT)
    Products = models.ForeignKey(Products,on_delete=models.PROTECT, related_name='orderItems')
    quentity = models.PositiveSmallIntegerField()
    unit_price = models.DecimalField(max_digits=6,decimal_places=2)

class Cart(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid4)
    created_at = models.DateTimeField(auto_now_add=True)

class Address(models.Model):
    street = models.CharField(max_length=255)  # Corrected max_length
    city = models.CharField(max_length=255)  
    

    #one to one relationship
    Customers = models.OneToOneField(Customers,on_delete=models.CASCADE, primary_key=True ) 

class CartItem(models.Model):
    cart = models.ForeignKey(Cart,on_delete=models.CASCADE, related_name='items') #
    product = models.ForeignKey(Products,on_delete=models.CASCADE)
    quantity = models.PositiveSmallIntegerField()

    unique_together = [['cart','products']] #for unique generated....



class Review(models.Model):
    product = models.ForeignKey(Products,on_delete=models.CASCADE, related_name='review')
    name = models.CharField(max_length=255)
    describtion = models.TextField()
    date = models.DateField(auto_now_add=True)
---------------------------

-------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
---------------------------------------CartItem Full ----------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
urls -> views -> serializer (return Json formet data , take data fields from Models/ Template.html alternatives...).
---------------------------------------------------------------------------------------------
store::urls.py=>
================
from django.urls import path
from store import views
#default router show the api endpoint urls.
from rest_framework_nested import routers


app_name = 'store'


router = routers.DefaultRouter()
router.register(r'product', views.ProductViewSet, basename='product') #assertions baseName error that's why add base name
router.register(r'collection', views.CollectionViewSet)
router.register(r'cart',views.CartViewSet,basename='cart')

#for retrive reviews form product use => 
product_router = routers.NestedDefaultRouter(router, r'product', lookup='product')
product_router.register(r'review', views.ReviewViewSet, basename='product-reviews')

#for retrive cartItem form cart use=> 
cart_router = routers.NestedDefaultRouter(router, r'cart', lookup='cart') # send to cart_pk to CartItemViews.
cart_router.register(r'cartItem', views.CartItemViewSet, basename='cart-items') #basename has 2 route cart-item-detials/ cart-item-list #as nested routers

urlpatterns = [] + router.urls + product_router.urls + cart_router.urls 


---------------------------
---------------------------
store::views.py=> 
---------------------------

from rest_framework.response import Response #serializers to Json formater
from store.models import Products,Collections,OrderItems,Review,Cart,CartItem
from store.serializers import ProductSerializer,CollectionsSerializer,ReviewSerializer,CartSerializer,CartItemSerializer,AddCartItemSerializer,UpdateCartItemSerializer
from django.db.models import Count



from rest_framework.viewsets import ModelViewSet
from django_filters.rest_framework import DjangoFilterBackend# filter easyly with any Db.coloumn like price ...
from rest_framework.filters import SearchFilter,OrderingFilter # for search,sorting -> product 
from rest_framework.pagination import PageNumberPagination #paginations
from .filters import ProductFilter 
from store.paginations import DefaultPagination #cutom paginations.

#import for cart:
from rest_framework.mixins import CreateModelMixin,RetrieveModelMixin,ListModelMixin,DestroyModelMixin
from rest_framework.viewsets import GenericViewSet

class ProductViewSet(ModelViewSet):

    queryset = Products.objects.all()
    serializer_class = ProductSerializer

    #for filter: =>-------------------------
    filter_backends = [DjangoFilterBackend,SearchFilter,OrderingFilter]
    # pagination_class = PageNumberPagination
    pagination_class = DefaultPagination  #custom paginations
    # filterset_fields = ['collections_id']
    filterset_class = ProductFilter #import form custom file.
    search_fields  = ['title', 'describtion'] #search box working with those fields.
    ordering_fields = ['unit_price','last_update']



    def get_serializer_context(self): #for serializer extra variable /mehtod to send to serializer
        return {'request':self.request}
    
    def destroy(self, request, *args, **kwargs):
          if OrderItems.objects.filter(product__id=kwargs['pk']).count() > 0:  #aggregations-> count(), ORM query fn-> Count().
                return Response({"error": "product can't be delete cause in orderitem"},)
         
          return super().destroy(request, *args, **kwargs)
  




# --------------------------------collections-------------------------------------



class CollectionViewSet(ModelViewSet):
        
        queryset = Collections.objects.annotate(products_count=Count('products')).all()
        serializer_class = CollectionsSerializer

        def destroy(self, request, *args, **kwargs):
             if OrderItems.products.filter(product__id=kwargs['pk']).count() > 0:  # Changed 'collection' to 'collection'
                return Response({'error': "collections can't be deleted because order items are included"})
             
             return super().destroy(request, *args, **kwargs)
       

class ReviewViewSet(ModelViewSet):
     #cutom query : cz reviews show for every product : filter review for indivisual products.
     def get_queryset(self):
         return Review.objects.filter(product_id =self.kwargs['product_pk'])
     

     #use this method for => send data to Review serializer
     def get_context_data(self) :
         return {'product_id':self.kwargs['product_pk']}
     
     
     serializer_class = ReviewSerializer


class CartViewSet(CreateModelMixin,RetrieveModelMixin,ListModelMixin,DestroyModelMixin,GenericViewSet):
     
    #  queryset = Cart.objects.all()
     queryset = Cart.objects.prefetch_related('items__product').all() #cart -> Fk-> CartItem(related_name=items), instide cartItem Fk-> Products(product) | optimize the query
     serializer_class = CartSerializer


#show single items of cart: 
class CartItemViewSet(ModelViewSet): #tabels need , cart_id, product_id, quantity in DB.
   
    #allow http method : 
    http_method_names = ['get', 'post','patch','delete'] #declare those methods which we want to use.

    #for add cartItem use custom serializer: 
    def get_serializer_class(self):
         if self.request.method == "POST":
              return AddCartItemSerializer #use for add new cartItem.
         elif self.request.method == "PATCH":
              return UpdateCartItemSerializer
         
         return CartItemSerializer # use for get() cartItem.
    

    def get_serializer_context(self): #data collect from urls , then send to serializer 
         return {'cart_id':self.kwargs['cart_pk']}
   


     #need single cartItem hast cart_id column , so need cart_ID+ to catch  :
    def get_queryset(self):
          return CartItem.objects.\
                        filter(cart_id=self.kwargs['cart_pk']).\
                        select_related('product')


---------------------------
---------------------------
serializer.py=> 
---------------------------
from decimal import Decimal
from rest_framework import serializers
from store.models import Products,Collections,Review,Cart,CartItem

class ProductSerializer(serializers.ModelSerializer):
    

    class Meta : 
        model = Products
        fields = ['title', 'price', 'collections','price_with_tax','inventory','describtion'] #first search fields form model , if not find . then search => price , collections, tax_with price

  
    price = serializers.DecimalField(max_digits=6, decimal_places=2, source='unit_price') #custome name price => comes from unit_prime -> product(model)
    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')

    def calculate_tax(self, product:Products):
        return product.unit_price * Decimal(1.1)



class CollectionsSerializer(serializers.ModelSerializer):
    products_count = serializers.IntegerField(read_only=True)  # Add this line

    class Meta: 
        model = Collections
        fields = ['id', 'title', 'products_count']

        


class ReviewSerializer(serializers.ModelSerializer):

    class Meta: 
        model = Review
        fields = ['id', 'date','name', 'describtion','product']

    #Receive data from context method form views.Reveiws (product_id, reviews_also )
    def create(self,validated_data):
        product_id = self.context ['product_id']
        return Review.objects.create(product_id=product_id,**validated_data)




#Cart take cartItems from CartItem serializers (parent - cart , child - cartItem):----------------------------

class SimpleProductSerializer(serializers.ModelSerializer):

    class Meta:
        model = Products
        fields = ['pk', 'title','unit_price']


class CartItemSerializer(serializers.ModelSerializer):
    product = SimpleProductSerializer() 
    total_price = serializers.SerializerMethodField()

    def get_total_price(self, cart_item: CartItem):
        return cart_item.quantity * cart_item.product.unit_price

    class Meta:
        model = CartItem
        fields = ['id', 'product', 'quantity', 'total_price']


class AddCartItemSerializer(serializers.ModelSerializer):
    product_id = serializers.IntegerField()

    class Meta:
        model = CartItem 
        fields = ['id','product_id','quantity'] #those field get from DB . if need extra data in varibale then we use self.request -> get data from url through get_context(self.kwagrs['paramsName-which get from urls/users']) for serializer.

    #data validation which get from url/users: if user input wrong product_id then => 
    def validate_product_id(self,value):
        if not Products.objects.filter(pk=value).exists():
            raise serializers.ValidationError('No Product Fount with the given ID')
        return value
    
    def save(self, **kwargs): #*** in serializer can't get params from urls , that's why use get_context() method in views to pass data into serializer.
        #in views we are using => serializer.is_validate():  -> serializer.save() 
        cart_id = self.context['cart_id'] #get from  views.context(method)
        product_id = self.validated_data['product_id'] #get from  urls
        quantity = self.validated_data['quantity'] #get from  urls

        try:
            cart_item = CartItem.objects.get(cart_id=cart_id, product_id=product_id)  #if get cart item then just update cartItem. and increase the quantity.
            cart_item.quantity += quantity
            cart_item.save()
            self.instance = cart_item#if Model get any data then update and return instance
        except CartItem.DoesNotExist:
            product = Products.objects.get(pk=product_id)
            self.instance = CartItem.objects.create(cart_id=cart_id, product=product, quantity=quantity)#if not found any cartItem then create new Item
             #  or user => 
             #  self.instance = CartItem.objects.create(cart_id=cart_id, **self.validated_data)
        return self.instance #if model not get any data then create new instance then return to db.


class UpdateCartItemSerializer(serializers.ModelSerializer):

    class Meta : 
        model = CartItem 
        fields = ['quantity']

        




class CartSerializer(serializers.ModelSerializer):
    id = serializers.UUIDField(read_only=True)
    items = CartItemSerializer(many=True, read_only=True )  # Set read_only=True
    total_price = serializers.SerializerMethodField()

    def get_total_price(self,cart:Cart):
        return sum([item.quantity * item.product.unit_price for item in cart.items.all()]) #most important Line.

    class Meta:
        model = Cart
        fields = ['id', 'items', 'total_price']





---------------------------
---------------------------
models.py=> 
---------------------------
from django.db import models
from uuid import uuid4 #for generate cart unique number.

# Create your models here.


class Promotions(models.Model):
    describtion = models.CharField(max_length=255)
    discount = models.FloatField()


class Collections(models.Model):
    title = models.CharField(max_length=255)
    featured_product = models.ForeignKey('Products',on_delete=models.SET_NULL, null=True, related_name='+')

    def __str__(self):
        return self.title 
    
    class Meta:
        ordering = ['title']

    


class Products (models.Model):
    slug = models.SlugField()
    sku = models.CharField(max_length=10,primary_key=True)
    title = models.CharField(max_length=255)
    describtion = models.TextField()
    unit_price = models.DecimalField(max_digits=10, decimal_places=2) 
    inventory = models.IntegerField()
    last_update = models.DateTimeField(auto_now=True)
    collections = models.ForeignKey(Collections,on_delete=models.PROTECT,related_name='products') # if want to delete Collections , Before must be delete Products .
    promotions = models.ManyToManyField(Promotions)

    def __str__(self) -> str:
        return self.title
    
    class Meta: 
        ordering = ['title']




class Customers(models.Model):
    MEMBERSHIP_BRONZE = 'B'
    MEMBERSHIP_SLIVER = 'S'
    MEMBERSHIP_GOLD = 'G'
    MEMBERSHIP_CHOICE = [
    ('MEMBERSHIP_BRONZE','Bronze'),
    ('MEMBERSHIP_SLIVER','Silver'),
    ('MEMBERSHIP_GOLD','Gold'),
    ]

    first_name = models.CharField(max_length=255)
    last_name = models.CharField(max_length=255)
    email = models.EmailField(unique=True)
    phone = models.IntegerField()
    brith_date = models.DateField(null=True)
    membership = models.CharField(max_length=17, choices=MEMBERSHIP_CHOICE, default=MEMBERSHIP_BRONZE)
    
    def __str__(self):
        return f"{self.first_name} {self.last_name }"


    class Meta:
        ordering = ['first_name', 'last_name']



class Order(models.Model):
    PAYMENT_STATUS_PENDING = 'P'
    PAYMENT_STATUS_COMPLETE = 'C'
    PAYMENT_STATUS_FAILD = 'F'
    PAYMENT_STATUS_CHOICE = [
        ('PAYMENT_STATUS_PENDING','P'),
        ('PAYMENT_STATUS_COMPLETE','C'),
        ('PAYMENT_STATUS_FAILD','F'),
    ]
    place_order = models.DateTimeField(auto_now_add=True)
    payment_status = models.CharField(
    max_length=23, choices=PAYMENT_STATUS_CHOICE, default=PAYMENT_STATUS_PENDING
    )

    Customers = models.ForeignKey(Customers,on_delete=models.PROTECT) #if accidently delete the Customers , we don't delete the order .

class OrderItems(models.Model):
    order = models.ForeignKey(Order,on_delete=models.PROTECT)
    Products = models.ForeignKey(Products,on_delete=models.PROTECT, related_name='orderItems')
    quentity = models.PositiveSmallIntegerField()
    unit_price = models.DecimalField(max_digits=6,decimal_places=2)

class Cart(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid4)
    created_at = models.DateTimeField(auto_now_add=True)

class Address(models.Model):
    street = models.CharField(max_length=255)  # Corrected max_length
    city = models.CharField(max_length=255)  
    

    #one to one relationship
    Customers = models.OneToOneField(Customers,on_delete=models.CASCADE, primary_key=True ) 

class CartItem(models.Model):
    cart = models.ForeignKey(Cart,on_delete=models.CASCADE, related_name='items') #
    product = models.ForeignKey(Products,on_delete=models.CASCADE)
    quantity = models.PositiveSmallIntegerField()

    unique_together = [['cart','products']] #for unique generated....



class Review(models.Model):
    product = models.ForeignKey(Products,on_delete=models.CASCADE, related_name='review')
    name = models.CharField(max_length=255)
    describtion = models.TextField()
    date = models.DateField(auto_now_add=True)
---------------------------
---------------------------

-------------------------------------------------------------------------------------------------------------
------------------------------------Authentications : Core-------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------


>>> create a new app => core and setup with the setting.py . for Authentications we use this app.
-------------------------------------------------------------------------------------------------------------
>>>settings.py  add this line => AUTH_USER_MODEL = 'core.User' 
--------------------------
likes.LikeItem.users: (fields.E301) Field defines a relation with the model 'auth.User', which has been swapped out.
        HINT: Update the relation to point at 'settings.AUTH_USER_MODEL'.
    
*** this error generated cause the Likes app depends on buildin User Model . for fixing import the core app model in 
like app model => from core.models import User |  in like app models.py=> 
> add this line too =>     users = models.ForeignKey(settings.AUTH_USER_MODEL , on_delete=models.CASCADE)


>>>python manage.py makemigrations 
>>> python manage.py migrate 

But we can't migrate the DB cause of => 
-------------------------------------------
*** for custom user model we have to do it , at the beggin part ... at the middle stage if we wanna go to modify 
    then we have to drop the database .... which is not good right.
    ---------------------------------------------------------------
so goto DB in console => 

>>> DROP DATABASES storefront;
>>> CREATE DATABASES storefront;

then we can migrate => >>> python manage.py migrate 
----------------------------------
----------------------------------
store::core::models.py=> 
----------------------------------
from django.db import models

from django.utils import timezone
from django.contrib.auth.models import AbstractBaseUser, BaseUserManager, PermissionsMixin


class CustomUserManager(BaseUserManager):
    # Your custom manager code here
    def create_user(self, email, username, password=None, **extra_fields):
        if not email:
            raise ValueError('The Email field must be set')
        email = self.normalize_email(email)
        user = self.model(email=email, username=username, **extra_fields)
        user.set_password(password)
        user.save(using=self._db)
        return user

    def create_superuser(self, email, username, password=None, **extra_fields):
        extra_fields.setdefault('is_staff', True)
        extra_fields.setdefault('is_superuser', True)

        if extra_fields.get('is_staff') is not True:
            raise ValueError('Superuser must have is_staff=True.')
        if extra_fields.get('is_superuser') is not True:
            raise ValueError('Superuser must have is_superuser=True.')

        return self.create_user(email, username, password, **extra_fields)


class User(AbstractBaseUser, PermissionsMixin):


    username = models.CharField(max_length=30, unique=True)
    email = models.EmailField(unique=True)
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    is_staff = models.BooleanField(default=False)
    is_active = models.BooleanField(default=True)
    is_superuser= models.BooleanField(default=False)
    # Other fields...
    date_joined = models.DateTimeField(default=timezone.now)  # Add date_joined field
    
    objects = CustomUserManager()

    REQUIRED_FIELDS = ['email', 'first_name', 'last_name'] # Add required fields

    USERNAME_FIELD = 'username'  # Set the username field

    def __str__(self):
        return self.username





----------------------------------
----------------------------------
store::core::admin.py=> 
----------------------------------
from django.contrib import admin

#import file for customer admin user model register: 
from store.models import Products
from django.contrib.contenttypes.admin import GenericTabularInline
from store.admin import ProductAdmin
from taqs.models import TaggItem 
# --------------------------------------
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin
from .models import User

# 
@admin.register(User)
class UserAdmin(BaseUserAdmin):
    list_display = ('username', 'email', 'first_name', 'last_name', 'is_staff', 'is_active')
    list_filter = ('is_staff', 'is_active')

    #those feilds copy from => UserAdmin Class: => 
    add_fieldsets = (
        (
            None,
            {
                "classes": ("wide",),
                "fields": ("username", "password1", "password2","email","first_name","last_name"),
            },
        ),
    )

----------------------------------
----------------------------------
----------------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------------
---------------------------------------Customer ----------------------------------------------------------------------

store::models.py=> 
==================
from django.db import models
from uuid import uuid4 #for generate cart unique number.

#import for users links with profile: 
from django.conf import settings
#improt admin for display first_name, last_name as ordering : 
from django.contrib import admin

# Create your models here.


class Promotions(models.Model):
    describtion = models.CharField(max_length=255)
    discount = models.FloatField()


class Collections(models.Model):
    title = models.CharField(max_length=255)
    featured_product = models.ForeignKey('Products',on_delete=models.SET_NULL, null=True, related_name='+')

    def __str__(self):
        return self.title 
    
    class Meta:
        ordering = ['title']

    


class Products (models.Model):
    slug = models.SlugField()
    sku = models.CharField(max_length=10,primary_key=True)
    title = models.CharField(max_length=255)
    describtion = models.TextField()
    unit_price = models.DecimalField(max_digits=10, decimal_places=2) 
    inventory = models.IntegerField()
    last_update = models.DateTimeField(auto_now=True)
    collections = models.ForeignKey(Collections,on_delete=models.PROTECT,related_name='products') # if want to delete Collections , Before must be delete Products .
    promotions = models.ManyToManyField(Promotions)

    def __str__(self) -> str:
        return self.title
    
    class Meta: 
        ordering = ['title']




# class Customers(models.Model):
#     MEMBERSHIP_BRONZE = 'B'
#     MEMBERSHIP_SLIVER = 'S'
#     MEMBERSHIP_GOLD = 'G'
#     MEMBERSHIP_CHOICE = [
#     ('MEMBERSHIP_BRONZE','Bronze'),
#     ('MEMBERSHIP_SLIVER','Silver'),
#     ('MEMBERSHIP_GOLD','Gold'),
#     ]

#     first_name = models.CharField(max_length=255)
#     last_name = models.CharField(max_length=255)
#     email = models.EmailField(unique=True)
#     phone = models.IntegerField()
#     brith_date = models.DateField(null=True)
#     membership = models.CharField(max_length=17, choices=MEMBERSHIP_CHOICE, default=MEMBERSHIP_BRONZE)
#     # orders = models.ManyToManyField(Order)
#     #Link to the user Model: 
#     user = models.OneToOneField(settings.AUTH_USER_MODEL,on_delete=models.CASCADE)


#     # def __str__(self):
#     #     return f"{self.first_name} {self.last_name }"
    

#     #this 2 functions pass to admin.py=> 
#     @admin.display(ordering='user__first_name')
#     def first_name(self):
#         return self.user.first_name
    
#     @admin.display(ordering='user__last_name')
#     def last_name(self):
#         return self.user.last_name
    
    
#     def get_order_count(self):
#         return self.order_set.count()


#     class Meta:
#         ordering = ['user__first_name', 'user__last_name']



class Customers(models.Model):
    MEMBERSHIP_BRONZE = 'B'
    MEMBERSHIP_SILVER = 'S'
    MEMBERSHIP_GOLD = 'G'
    MEMBERSHIP_CHOICES = [
        ('MEMBERSHIP_BRONZE', 'Bronze'),
        ('MEMBERSHIP_SILVER', 'Silver'),
        ('MEMBERSHIP_GOLD', 'Gold'),
    ]

    first_name = models.CharField(max_length=255)
    last_name = models.CharField(max_length=255)
    email = models.EmailField(unique=True)
    phone = models.IntegerField()
    birth_date = models.DateField(null=True)
    membership = models.CharField(max_length=17, choices=MEMBERSHIP_CHOICES, default=MEMBERSHIP_BRONZE)
    user = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)

    @admin.display(ordering='user__first_name')
    def first_name(self):
        return self.user.first_name
    
    @admin.display(ordering='user__last_name')
    def last_name(self):
        return self.user.last_name
    
    def get_order_count(self):
        return self.order_set.count()

    class Meta:
        ordering = ['user__first_name', 'user__last_name']


class Order(models.Model):
    PAYMENT_STATUS_PENDING = 'P'
    PAYMENT_STATUS_COMPLETE = 'C'
    PAYMENT_STATUS_FAILD = 'F'
    PAYMENT_STATUS_CHOICE = [
        ('PAYMENT_STATUS_PENDING','P'),
        ('PAYMENT_STATUS_COMPLETE','C'),
        ('PAYMENT_STATUS_FAILD','F'),
    ]
    place_order = models.DateTimeField(auto_now_add=True)
    payment_status = models.CharField(
    max_length=23, choices=PAYMENT_STATUS_CHOICE, default=PAYMENT_STATUS_PENDING
    )

    Customers = models.ForeignKey(Customers,on_delete=models.PROTECT) #if accidently delete the Customers , we don't delete the order .

class OrderItems(models.Model):
    order = models.ForeignKey(Order,on_delete=models.PROTECT)
    Products = models.ForeignKey(Products,on_delete=models.PROTECT, related_name='orderItems')
    quentity = models.PositiveSmallIntegerField()
    unit_price = models.DecimalField(max_digits=6,decimal_places=2)

class Cart(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid4)
    created_at = models.DateTimeField(auto_now_add=True)

class Address(models.Model):
    street = models.CharField(max_length=255)  # Corrected max_length
    city = models.CharField(max_length=255)  
    

    #one to one relationship
    Customers = models.OneToOneField(Customers,on_delete=models.CASCADE, primary_key=True ) 

class CartItem(models.Model):
    cart = models.ForeignKey(Cart,on_delete=models.CASCADE, related_name='items') #
    product = models.ForeignKey(Products,on_delete=models.CASCADE)
    quantity = models.PositiveSmallIntegerField()

    unique_together = [['cart','products']] #for unique generated....



class Review(models.Model):
    product = models.ForeignKey(Products,on_delete=models.CASCADE, related_name='review')
    name = models.CharField(max_length=255)
    describtion = models.TextField()
    date = models.DateField(auto_now_add=True)



------------------------------
------------------------------
store::admin.py=> 
------------------------------
from django.db import models

from typing import Any
from django.contrib import admin
from django.db.models.query import QuerySet
from django.http.request import HttpRequest
from django.db.models import Count,Min,Max,Avg,Sum

from . import models


@admin.register(models.Products)
class ProductAdmin(admin.ModelAdmin):
    list_display = ['title', 'unit_price', 'inventory_status', 'collections_title'] # show the title and unit_price in admin page, product has a link with collections table with collections column.
    list_editable = ['unit_price'] #now can edit -> 'unit_price' column.
    list_per_page = 10 #paginations .
    ordering = ['title', 'unit_price'] #accending order with titel and followed by unit_price.
    list_select_related = ['collections'] # Product Fk with Collections , collections form collections table in Product table


    def collections_title(self,product): #this product varible reffer to the Product Models.
        return product.collections.title 


    #return inventory coloumn in admin panel as string : 
    # if inventory is < 10 : show low or show 'high'

    @admin.display(ordering='inventory') # show admin panael inventory as accending order.
    def inventory_status(self, product): # this product varibale work with 'inventory_status' column.
        if product.inventory < 10:
            return 'Low'
        return 'Ok'
    

@admin.register(models.Order)
class OrderAdmin(admin.ModelAdmin):
    list_display = ['id', 'place_order', 'customers', 'payment_status']
    list_editable = ['payment_status']
    list_per_page = 10

    

    def place_order(self, order):
        return order.place_order

    def customers(self, order):
        return order.Customers


# @admin.register(models.Customers)
# class CustomerAdmin(admin.ModelAdmin):
#     list_display = ['first_name', 'last_name', 'membership','orders']
#     list_editable = ['membership']
#     list_per_page = 10
#     list_select_related = ['user']
#     ordering = ['user__first_name', 'user__last_name']

from django.contrib import admin
from .models import Customers, Order

# @admin.register(Customers)
# class CustomerAdmin(admin.ModelAdmin):
#     list_display = ['first_name', 'last_name', 'membership', 'display_orders']
#     list_editable = ['membership']
#     list_per_page = 10
    


#     """
#         In this case, obj will be an instance of the Customers model because we're working within the CustomerAdmin class.
#           This means obj will represent a specific customer.
#     """
#     def display_orders(self, obj):
#         orders = Order.objects.filter(Customers=obj)
#         return ', '.join([str(order.id) for order in orders])



#     display_orders.short_description = 'Orders' #admin panel name is Orders

@admin.register(models.Customers)
class CustomerAdmin(admin.ModelAdmin):
    list_display = ['first_name', 'last_name', 'membership', 'get_order_count']
    list_editable = ['membership']
    list_per_page = 10
    list_select_related = ['user']
    ordering = ['user__first_name', 'user__last_name']

    def get_order_count(self, obj):
        return obj.order_set.count() #customer parent , order child fk with customer. so , customer get order_set as default relative name.
    get_order_count.admin_order_field = 'order_set_count'
    get_order_count.short_description = 'Order Count'



#insert custom table with annotate -------------------------------

@admin.register(models.Collections)
class CollectionsAdmin(admin.ModelAdmin):
    list_display = ['title', 'featured_product', 'product_count']
    list_editable = ['featured_product']

    def product_count(self, collections):
        return collections.product_count

    def get_queryset(self, request):
        return super().get_queryset(request).annotate(
            product_count=Count('products') # this variable comes from Collections Models. if reserve error then change the Variable name
        )


# Register your models here.
# admin.site.register(models.Collections) or use => @admin.register(models.Collections)


------------------------------
-------------------------------------------------------------------------------------------------------------
---------------------------------------Group & Permission----------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
create_group > goto group | select app_table ex: store order/customer , select all | then add . 

then goto user > select a member as -> stuff status. -> then select the group and save . 

                > now login with the userName and Password , already we add the user as group member. 

                > Now this user has a permission to CRUD of Orders/Customers.




-------------------------------------------------------------------------------------------------------------
----------------------------------------Custom permission add ---------------------------------------------------------------------

store::models.py=> 
------------------
class Order(models.Model):
    PAYMENT_STATUS_PENDING = 'P'
    PAYMENT_STATUS_COMPLETE = 'C'
    PAYMENT_STATUS_FAILD = 'F'
    PAYMENT_STATUS_CHOICE = [
        ('PAYMENT_STATUS_PENDING','P'),
        ('PAYMENT_STATUS_COMPLETE','C'),
        ('PAYMENT_STATUS_FAILD','F'),
    ]
    place_order = models.DateTimeField(auto_now_add=True)
    payment_status = models.CharField(
    max_length=23, choices=PAYMENT_STATUS_CHOICE, default=PAYMENT_STATUS_PENDING
    )

    customers = models.ForeignKey(Customers,on_delete=models.PROTECT) #if accidently delete the Customers , we don't delete the order .

    class Meta: 
        permissions=[
            ('cancel_order', 'Can cancel Order')
        ]

        >>>python manage.py makemigrations
        >>>python manage.py migrate
        >>>then goto the admin panel and search permission in group.
-------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
----------------------------------Token Base Authentications---------------------------------------------------------------------------


for token Base Authentications install package => djoser package . 

>>> after installations goto >>> Main.Product.Urls => path('auth/',include('djoser.urls')),

>>>pip install -U djangorestframework_simplejwt

>>> setting.py=>

 #token base Authentications => 
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework_simplejwt.authentication.JWTAuthentication',
       
    ),
}
SIMPLE_JWT = {
   'AUTH_HEADER_TYPES': ('JWT',),
}

>>> Main.Projects.urls=> 
-------------------------
from django.contrib import admin
from django.urls import path, include
from playground import views



admin.site.site_header = "StoreFront " #admin page heading 
admin.site.index_title = "Admin" #admin page title

urlpatterns = [
    path('admin/', admin.site.urls),
    path('playground/', include('playground.urls')),
    path('store/', include('store.urls')),
    path('auth/',include('djoser.urls')),
    path('auth/',include('djoser.urls.jwt')),
    path("__debug__/", include("debug_toolbar.urls")),
]


>>> http://127.0.0.1:8000/auth/users/   | hit the url.
-------------------------------------------------------------------------------------------------------------
------------------------------------------customize the Djoser Serializer-------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
# for create new user We need to customize the Djoser Serializer.
>>> core app >>> create new file >>> serializer.py-> 

--------------------------------------------
core::serializers.py=> 
-----------------------------------

from djoser.serializers import UserCreateSerializer as BaseUserCreateSerializer


class UserCreateSerializer(BaseUserCreateSerializer):
    
    class Meta(BaseUserCreateSerializer.Meta): # we just over write the fields.
        fields = ['id', 'username', 'password','email','first_name', 'last_name' ]
-----------------------------------
-----------------------------------
core::models.py=> 
-----------------------------------
from django.db import models

from django.utils import timezone
from django.contrib.auth.models import AbstractBaseUser, BaseUserManager, PermissionsMixin


class CustomUserManager(BaseUserManager):
    # Your custom manager code here
    def create_user(self, email, username, password=None, **extra_fields):
        if not email:
            raise ValueError('The Email field must be set')
        email = self.normalize_email(email)
        user = self.model(email=email, username=username, **extra_fields)
        user.set_password(password)
        user.save(using=self._db)
        return user

    def create_superuser(self, email, username, password=None, **extra_fields):
        extra_fields.setdefault('is_staff', True)
        extra_fields.setdefault('is_superuser', True)

        if extra_fields.get('is_staff') is not True:
            raise ValueError('Superuser must have is_staff=True.')
        if extra_fields.get('is_superuser') is not True:
            raise ValueError('Superuser must have is_superuser=True.')

        return self.create_user(email, username, password, **extra_fields)


class User(AbstractBaseUser, PermissionsMixin):


    username = models.CharField(max_length=30, unique=True)
    email = models.EmailField(unique=True)
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

    is_staff = models.BooleanField(default=False)
    is_active = models.BooleanField(default=True)
    # Other fields...
    date_joined = models.DateTimeField(default=timezone.now)  # Add date_joined field
    
    objects = CustomUserManager()

    REQUIRED_FIELDS = ['email', 'first_name', 'last_name'] # Add required fields

    USERNAME_FIELD = 'username'  # Set the username field

    def __str__(self):
        return self.username



>>> now try to add new user -> http://127.0.0.1:8000/auth/users/
-----------------------------------
-----------------------------------
-----------------------------------


-------------------------------------------------------------------------------------------------------------
-------------------------------------Create New Customer with API------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
>>> in store app we use models of Customers.... 
---------------------------------------------------
store::urls.py=> 
---------------
from django.urls import path
from store import views
#default router show the api endpoint urls.
from rest_framework_nested import routers


app_name = 'store'


router = routers.DefaultRouter()
router.register(r'product', views.ProductViewSet, basename='product') #assertions baseName error that's why add base name
router.register(r'collection', views.CollectionViewSet)
router.register(r'cart',views.CartViewSet,basename='cart')
router.register(r'customer', views.CustomerViewSet, basename='customer')

#for retrive reviews form product use => 
product_router = routers.NestedDefaultRouter(router, r'product', lookup='product')
product_router.register(r'review', views.ReviewViewSet, basename='product-reviews')

#for retrive cartItem form cart use=> 
cart_router = routers.NestedDefaultRouter(router, r'cart', lookup='cart') # send to cart_pk to CartItemViews.
cart_router.register(r'cartItem', views.CartItemViewSet, basename='cart-items') #basename has 2 route cart-item-detials/ cart-item-list #as nested routers

urlpatterns = [] + router.urls + product_router.urls + cart_router.urls 


------------------------
------------------------
store::views.py=> 
------------------------
------------------------
# ----------------------------------Customer Serializer-------------------------------------------------------

class CustomerSerializer(serializers.ModelSerializer):
    user_id = serializers.IntegerField()

    class Meta: 
        model = Customers
        fields = ['id', 'user_id', 'phone', 'email', 'birth_date', 'membership']
-------------------------
-------------------------
# ----------------------------------Customer Serializer-------------------------------------------------------

class CustomerSerializer(serializers.ModelSerializer):
    user_id = serializers.IntegerField()

    class Meta: 
        model = Customers
        fields = ['id', 'user_id', 'phone', 'email', 'birth_date', 'membership']
-------------------------
-------------------------
-------------------------------------------------------------------------------------------------------------
-------------------------------------------Login with token------------------------------------------------------------------
#we get the route from djoser official website. 
------------------------------------------------

>>> http://127.0.0.1:8000/auth/jwt/create/   | register user can login then get any token . 



{
    "refresh": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoicmVmcmVzaCIsImV4cCI6MTY5NTcyMzM5OSwiaWF0IjoxNjk1NjM2OTk5LCJqdGkiOiIwMDMyZTc0NTZmZDg0NzE5OWMzZWFjYmNjZjdjZmU5OSIsInVzZXJfaWQiOjF9.zGQsbwBRX2aqEDNXp5JBRugISEOuP2IXal8hzD_eQjY",
    "access": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNjk1NzIzMzk5LCJpYXQiOjE2OTU2MzY5OTksImp0aSI6ImVkNDRjOGZhZGVlMzRhMThiODBiNjQ5YTQ0YTIzN2I1IiwidXNlcl9pZCI6MX0.sO-_SfE95jVuxQRPG3TaEKkPL-iTu8N7QE7dLhzpfd0"
}

#we need to increase the life token => 
--------------------------------------
setting.py=> 
-------------
from datetime import timedelta
SIMPLE_JWT = {
   'AUTH_HEADER_TYPES': ('JWT',),
    "ACCESS_TOKEN_LIFETIME": timedelta(days=1),
}

----------------------------------------------

>>> now for login with JWT+token -> install mode header => Authorization+tokenPase the feild 
>>> http://127.0.0.1:8000/auth/users/me/  |hit the url , then we can login ... cz mode.header set the token to login.




-------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
#------------------------------Customer user -> JESON WEB TOKEN-------------------------------------------

from rest_framework.decorators import action #get, put, delete ...details = retrive...

class CustomerViewSet(GenericViewSet, CreateModelMixin, RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin):
    queryset = Customers.objects.all()
    serializer_class = CustomerSerializer

    @action(detail=False, methods=['GET', 'PUT'])
    def me(self, request):#http://127.0.0.1:8000/store/customer/me/ -> this /me = def me(function). & request.user -> anonimus functions of classes.
        customer, created = Customers.objects.get_or_create(user_id=request.user.id) #get_or_create -> method return 2 value: cutomerID, created/not_created boolean

        if request.method == 'GET':#also show the user id , but user_id can't edit by user. that's why make the CustomerSerializer -> user_id(read_only)
            serializer = CustomerSerializer(customer)
            return Response(serializer.data)

        elif request.method == 'PUT':
            serializer = CustomerSerializer(customer, data=request.data)
            serializer.is_valid(raise_exception=True)
            serializer.save()
            return Response(serializer.data)

     
------------------------------------
------------------------------------
store::serialer.py=> 
------------------------------------
# ----------------------------------Customer Serializer-------------------------------------------------------

class CustomerSerializer(serializers.ModelSerializer):
    user_id = serializers.IntegerField(read_only=True)

    class Meta: 
        model = Customers
        fields = ['id', 'user_id', 'phone', 'email', 'birth_date', 'membership']
------------------------------------
-------------------------------------------------------------------------------------------------------------
---------------------------------------route permission----------------------------------------------------------------------
store::views.py=> 
-----------------

from rest_framework.response import Response #serializers to Json formater
from store.models import Products,Collections,OrderItems,Review,Cart,CartItem,Customers
from store.serializers import ProductSerializer,CollectionsSerializer,ReviewSerializer,CartSerializer,CartItemSerializer,AddCartItemSerializer,UpdateCartItemSerializer,CustomerSerializer
from django.db.models import Count



from rest_framework.viewsets import ModelViewSet
from django_filters.rest_framework import DjangoFilterBackend# filter easyly with any Db.coloumn like price ...
from rest_framework.filters import SearchFilter,OrderingFilter # for search,sorting -> product 
from rest_framework.pagination import PageNumberPagination #paginations
from .filters import ProductFilter 
from store.paginations import DefaultPagination #cutom paginations.

#import for cart:
from rest_framework.mixins import CreateModelMixin,RetrieveModelMixin,ListModelMixin,DestroyModelMixin,UpdateModelMixin
from rest_framework.viewsets import GenericViewSet

class ProductViewSet(ModelViewSet):

    queryset = Products.objects.all()
    serializer_class = ProductSerializer

    #for filter: =>-------------------------
    filter_backends = [DjangoFilterBackend,SearchFilter,OrderingFilter]
    # pagination_class = PageNumberPagination
    pagination_class = DefaultPagination  #custom paginations
    # filterset_fields = ['collections_id']
    filterset_class = ProductFilter #import form custom file.
    search_fields  = ['title', 'describtion'] #search box working with those fields.
    ordering_fields = ['unit_price','last_update']



    def get_serializer_context(self): #for serializer extra variable /mehtod to send to serializer
        return {'request':self.request}
    
    def destroy(self, request, *args, **kwargs):
          if OrderItems.objects.filter(product__id=kwargs['pk']).count() > 0:  #aggregations-> count(), ORM query fn-> Count().
                return Response({"error": "product can't be delete cause in orderitem"},)
         
          return super().destroy(request, *args, **kwargs)
  




# --------------------------------collections-------------------------------------



class CollectionViewSet(ModelViewSet):
        
        queryset = Collections.objects.annotate(products_count=Count('products')).all()
        serializer_class = CollectionsSerializer

        def destroy(self, request, *args, **kwargs):
             if OrderItems.products.filter(product__id=kwargs['pk']).count() > 0:  # Changed 'collection' to 'collection'
                return Response({'error': "collections can't be deleted because order items are included"})
             
             return super().destroy(request, *args, **kwargs)
       

class ReviewViewSet(ModelViewSet):
     #cutom query : cz reviews show for every product : filter review for indivisual products.
     def get_queryset(self):
         return Review.objects.filter(product_id =self.kwargs['product_pk'])
     

     #use this method for => send data to Review serializer
     def get_context_data(self) :
         return {'product_id':self.kwargs['product_pk']}
     
     
     serializer_class = ReviewSerializer


class CartViewSet(CreateModelMixin,RetrieveModelMixin,ListModelMixin,DestroyModelMixin,GenericViewSet):
     
    #  queryset = Cart.objects.all()
     queryset = Cart.objects.prefetch_related('items__product').all() #cart -> Fk-> CartItem(related_name=items), instide cartItem Fk-> Products(product) | optimize the query
     serializer_class = CartSerializer


#show single items of cart: 
class CartItemViewSet(ModelViewSet): #tabels need , cart_id, product_id, quantity in DB.
   
    #allow http method : 
    http_method_names = ['get', 'post','patch','delete'] #declare those methods which we want to use.

    #for add cartItem use custom serializer: 
    def get_serializer_class(self):
         if self.request.method == "POST":
              return AddCartItemSerializer #use for add new cartItem.
         elif self.request.method == "PATCH":
              return UpdateCartItemSerializer
         
         return CartItemSerializer # use for get() cartItem.
    

    def get_serializer_context(self): #data collect from urls , then send to serializer 
         return {'cart_id':self.kwargs['cart_pk']}
   


     #need single cartItem hast cart_id column , so need cart_ID+ to catch  :
    def get_queryset(self):
          return CartItem.objects.\
                        filter(cart_id=self.kwargs['cart_pk']).\
                        select_related('product')



#------------------------------Customer user -> JESON WEB TOKEN-------------------------------------------

from rest_framework.decorators import action #get, put, delete ...details = retrive...
from rest_framework.permissions import IsAuthenticated,AllowAny#permisson for users

class CustomerViewSet(GenericViewSet, CreateModelMixin, RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin):
     queryset = Customers.objects.all()
     serializer_class = CustomerSerializer
     permission_classes = [IsAuthenticated]

     def get_permissions(self):
          if  self.request.method == 'GET':
               return [AllowAny()]
          return [IsAuthenticated()]

     @action(detail=False, methods=['GET', 'PUT'])
     def me(self, request):#http://127.0.0.1:8000/store/customer/me/ -> this /me = def me(function). & request.user -> anonimus functions of classes.
          customer, created = Customers.objects.get_or_create(user_id=request.user.id) #get_or_create -> method return 2 value: cutomerID, created/not_created boolean

          if request.method == 'GET':#also show the user id , but user_id can't edit by user. that's why make the CustomerSerializer -> user_id(read_only)
               serializer = CustomerSerializer(customer)
               return Response(serializer.data)

          elif request.method == 'PUT':
               serializer = CustomerSerializer(customer, data=request.data)
               serializer.is_valid(raise_exception=True)
               serializer.save()
               return Response(serializer.data)

     


-------------------------------------------------------------------------------------------------------------
--------------------------------Custom Permissions. ---------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
store::permission.py=> 
----------------------
from rest_framework import permissions



class IsAdminOrReadOnly(permissions.BasePermission):
    def has_permission(self, request, view):
        if request.method in permissions.SAFE_METHODS: #in safe methods has=> GET, HEAD, OPTIONS.
            return True
        return bool(request.user and request.user.is_staff)




# class IsAdminOrReadOnly(BasePermission):
#     def has_permission(self, request, view):
#         if request.method == 'GET':
#             return True
#         return bool(request.user and request.user.is_stuff)

---------------------------
---------------------------
store::views.py=> 
---------------------------

from rest_framework.response import Response #serializers to Json formater
from store.models import Products,Collections,OrderItems,Review,Cart,CartItem,Customers
from store.serializers import ProductSerializer,CollectionsSerializer,ReviewSerializer,CartSerializer,CartItemSerializer,AddCartItemSerializer,UpdateCartItemSerializer,CustomerSerializer
from django.db.models import Count



from rest_framework.viewsets import ModelViewSet
from django_filters.rest_framework import DjangoFilterBackend# filter easyly with any Db.coloumn like price ...
from rest_framework.filters import SearchFilter,OrderingFilter # for search,sorting -> product 
from rest_framework.pagination import PageNumberPagination #paginations
from .filters import ProductFilter 
from store.paginations import DefaultPagination #cutom paginations.

#import for cart:
from rest_framework.mixins import CreateModelMixin,RetrieveModelMixin,ListModelMixin,DestroyModelMixin,UpdateModelMixin
from rest_framework.viewsets import GenericViewSet
from .permissions import IsAdminOrReadOnly

class ProductViewSet(ModelViewSet):

    queryset = Products.objects.all()
    serializer_class = ProductSerializer

    #for filter: =>-------------------------
    filter_backends = [DjangoFilterBackend,SearchFilter,OrderingFilter]
    # pagination_class = PageNumberPagination
    pagination_class = DefaultPagination  #custom paginations
    # filterset_fields = ['collections_id']
    filterset_class = ProductFilter #import form custom file.
    search_fields  = ['title', 'describtion'] #search box working with those fields.
    ordering_fields = ['unit_price','last_update']
    permission_classes = [IsAdminOrReadOnly]



    def get_serializer_context(self): #for serializer extra variable /mehtod to send to serializer
        return {'request':self.request}
    
    def destroy(self, request, *args, **kwargs):
          if OrderItems.objects.filter(product__id=kwargs['pk']).count() > 0:  #aggregations-> count(), ORM query fn-> Count().
                return Response({"error": "product can't be delete cause in orderitem"},)
         
          return super().destroy(request, *args, **kwargs)
  




# --------------------------------collections-------------------------------------



class CollectionViewSet(ModelViewSet):
        permission_classes = [IsAdminOrReadOnly]
        
        queryset = Collections.objects.annotate(products_count=Count('products')).all()
        serializer_class = CollectionsSerializer
        

        def destroy(self, request, *args, **kwargs):
             if OrderItems.products.filter(product__id=kwargs['pk']).count() > 0:  # Changed 'collection' to 'collection'
                return Response({'error': "collections can't be deleted because order items are included"})
             
             return super().destroy(request, *args, **kwargs)
       

class ReviewViewSet(ModelViewSet):
     #cutom query : cz reviews show for every product : filter review for indivisual products.
     def get_queryset(self):
         return Review.objects.filter(product_id =self.kwargs['product_pk'])
     

     #use this method for => send data to Review serializer
     def get_context_data(self) :
         return {'product_id':self.kwargs['product_pk']}
     
     
     serializer_class = ReviewSerializer


class CartViewSet(CreateModelMixin,RetrieveModelMixin,ListModelMixin,DestroyModelMixin,GenericViewSet):
     
    #  queryset = Cart.objects.all()
     queryset = Cart.objects.prefetch_related('items__product').all() #cart -> Fk-> CartItem(related_name=items), instide cartItem Fk-> Products(product) | optimize the query
     serializer_class = CartSerializer


#show single items of cart: 
class CartItemViewSet(ModelViewSet): #tabels need , cart_id, product_id, quantity in DB.
   
    #allow http method : 
    http_method_names = ['get', 'post','patch','delete'] #declare those methods which we want to use.

    #for add cartItem use custom serializer: 
    def get_serializer_class(self):
         if self.request.method == "POST":
              return AddCartItemSerializer #use for add new cartItem.
         elif self.request.method == "PATCH":
              return UpdateCartItemSerializer
         
         return CartItemSerializer # use for get() cartItem.
    

    def get_serializer_context(self): #data collect from urls , then send to serializer 
         return {'cart_id':self.kwargs['cart_pk']}
   


     #need single cartItem hast cart_id column , so need cart_ID+ to catch  :
    def get_queryset(self):
          return CartItem.objects.\
                        filter(cart_id=self.kwargs['cart_pk']).\
                        select_related('product')



#------------------------------Customer user -> JESON WEB TOKEN-------------------------------------------

from rest_framework.decorators import action #get, put, delete ...details = retrive...
from rest_framework.permissions import IsAuthenticated,AllowAny#permisson for users

class CustomerViewSet(GenericViewSet, CreateModelMixin, RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin):
     queryset = Customers.objects.all()
     serializer_class = CustomerSerializer
     permission_classes = [IsAuthenticated]

     def get_permissions(self):
          if self.request.method == 'GET':
               return [AllowAny()]
          return [IsAuthenticated()]

     @action(detail=False, methods=['GET', 'PUT'], permission_classes=[IsAuthenticated])
     def me(self, request):#http://127.0.0.1:8000/store/customer/me/ -> this /me = def me(function). & request.user -> anonimus functions of classes.
          customer, created = Customers.objects.get_or_create(user_id=request.user.id) #get_or_create -> method return 2 value: cutomerID, created/not_created boolean

          if request.method == 'GET':#also show the user id , but user_id can't edit by user. that's why make the CustomerSerializer -> user_id(read_only)
               serializer = CustomerSerializer(customer)
               return Response(serializer.data)

          elif request.method == 'PUT':
               serializer = CustomerSerializer(customer, data=request.data)
               serializer.is_valid(raise_exception=True)
               serializer.save()
               return Response(serializer.data)

     


     


-------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
----------------------------------------Django Model Permission---------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
store::permissions.py=> 
-----------------------
from rest_framework import permissions



class IsAdminOrReadOnly(permissions.BasePermission):
    def has_permission(self, request, view):
        if request.method in permissions.SAFE_METHODS: #in safe methods has=> GET, HEAD, OPTIONS.
            return True
        return bool(request.user and request.user.is_staff)



#for Model permissions.
class FullDjangoModelPermission(permissions.DjangoModelPermissions):
    def __init__(self) -> None:
        self.perms_map['GET']:  ['%(app_label)s.view_%(model_name)s'] #only get is we allow here . though user have all permessions but only get permission we just provid.

-----------------------------
-----------------------------
store::views.py=> 
-----------------------------

from rest_framework.response import Response #serializers to Json formater
from store.models import Products,Collections,OrderItems,Review,Cart,CartItem,Customers
from store.serializers import ProductSerializer,CollectionsSerializer,ReviewSerializer,CartSerializer,CartItemSerializer,AddCartItemSerializer,UpdateCartItemSerializer,CustomerSerializer
from django.db.models import Count



from rest_framework.viewsets import ModelViewSet
from django_filters.rest_framework import DjangoFilterBackend# filter easyly with any Db.coloumn like price ...
from rest_framework.filters import SearchFilter,OrderingFilter # for search,sorting -> product 
from rest_framework.pagination import PageNumberPagination #paginations
from .filters import ProductFilter 
from store.paginations import DefaultPagination #cutom paginations.

#import for cart:
from rest_framework.mixins import CreateModelMixin,RetrieveModelMixin,ListModelMixin,DestroyModelMixin,UpdateModelMixin
from rest_framework.viewsets import GenericViewSet
from .permissions import IsAdminOrReadOnly

class ProductViewSet(ModelViewSet):

    queryset = Products.objects.all()
    serializer_class = ProductSerializer

    #for filter: =>-------------------------
    filter_backends = [DjangoFilterBackend,SearchFilter,OrderingFilter]
    # pagination_class = PageNumberPagination
    pagination_class = DefaultPagination  #custom paginations
    # filterset_fields = ['collections_id']
    filterset_class = ProductFilter #import form custom file.
    search_fields  = ['title', 'describtion'] #search box working with those fields.
    ordering_fields = ['unit_price','last_update']
    permission_classes = [IsAdminOrReadOnly]



    def get_serializer_context(self): #for serializer extra variable /mehtod to send to serializer
        return {'request':self.request}
    
    def destroy(self, request, *args, **kwargs):
          if OrderItems.objects.filter(product__id=kwargs['pk']).count() > 0:  #aggregations-> count(), ORM query fn-> Count().
                return Response({"error": "product can't be delete cause in orderitem"},)
         
          return super().destroy(request, *args, **kwargs)
  




# --------------------------------collections-------------------------------------



class CollectionViewSet(ModelViewSet):
        permission_classes = [IsAdminOrReadOnly]
        
        queryset = Collections.objects.annotate(products_count=Count('products')).all()
        serializer_class = CollectionsSerializer
        

        def destroy(self, request, *args, **kwargs):
             if OrderItems.products.filter(product__id=kwargs['pk']).count() > 0:  # Changed 'collection' to 'collection'
                return Response({'error': "collections can't be deleted because order items are included"})
             
             return super().destroy(request, *args, **kwargs)
       

class ReviewViewSet(ModelViewSet):
     #cutom query : cz reviews show for every product : filter review for indivisual products.
     def get_queryset(self):
         return Review.objects.filter(product_id =self.kwargs['product_pk'])
     

     #use this method for => send data to Review serializer
     def get_context_data(self) :
         return {'product_id':self.kwargs['product_pk']}
     
     
     serializer_class = ReviewSerializer


class CartViewSet(CreateModelMixin,RetrieveModelMixin,ListModelMixin,DestroyModelMixin,GenericViewSet):
     
    #  queryset = Cart.objects.all()
     queryset = Cart.objects.prefetch_related('items__product').all() #cart -> Fk-> CartItem(related_name=items), instide cartItem Fk-> Products(product) | optimize the query
     serializer_class = CartSerializer


#show single items of cart: 
class CartItemViewSet(ModelViewSet): #tabels need , cart_id, product_id, quantity in DB.
   
    #allow http method : 
    http_method_names = ['get', 'post','patch','delete'] #declare those methods which we want to use.

    #for add cartItem use custom serializer: 
    def get_serializer_class(self):
         if self.request.method == "POST":
              return AddCartItemSerializer #use for add new cartItem.
         elif self.request.method == "PATCH":
              return UpdateCartItemSerializer
         
         return CartItemSerializer # use for get() cartItem.
    

    def get_serializer_context(self): #data collect from urls , then send to serializer 
         return {'cart_id':self.kwargs['cart_pk']}
   


     #need single cartItem hast cart_id column , so need cart_ID+ to catch  :
    def get_queryset(self):
          return CartItem.objects.\
                        filter(cart_id=self.kwargs['cart_pk']).\
                        select_related('product')



#------------------------------Customer user -> JESON WEB TOKEN-------------------------------------------

from rest_framework.decorators import action #get, put, delete ...details = retrive...
from rest_framework.permissions import IsAuthenticated,AllowAny,DjangoModelPermissions,DjangoModelPermissionsOrAnonReadOnly#permisson for users
from .permissions import FullDjangoModelPermission #cutom permission.

class CustomerViewSet(ModelViewSet):
     queryset = Customers.objects.all()
     serializer_class = CustomerSerializer
     permission_classes = [DjangoModelPermissionsOrAnonReadOnly] #use our custom class : FullDjangoModelPermission.

     
     @action(detail=False, methods=['GET','PUT'], permission_classes=[IsAuthenticated()])
     def me(self, request):#http://127.0.0.1:8000/store/customer/me/ -> this /me = def me(function). & request.user -> anonimus functions of classes.
          customer, created = Customers.objects.get_or_create(user_id=request.user.id) #get_or_create -> method return 2 value: cutomerID, created/not_created boolean

          if request.method == 'GET':#also show the user id , but user_id can't edit by user. that's why make the CustomerSerializer -> user_id(read_only)
               serializer = CustomerSerializer(customer)
               return Response(serializer.data)

          elif request.method == 'PUT':
               serializer = CustomerSerializer(customer, data=request.data)
               serializer.is_valid(raise_exception=True)
               serializer.save()
               return Response(serializer.data)

     


-----------------------------
-----------------------------

-------------------------------------------------------------------------------------------------------------
--------------------------------------Custom Model Permission-----------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
store::permessions=> 
---------------------
from rest_framework import permissions



class IsAdminOrReadOnly(permissions.BasePermission):
    def has_permission(self, request, view):
        if request.method in permissions.SAFE_METHODS: #in safe methods has=> GET, HEAD, OPTIONS.
            return True
        return bool(request.user and request.user.is_staff)




class FullDjangoModelPermission(permissions.DjangoModelPermissions):
    def __init__(self) -> None:
        self.perms_map['GET']:  ['%(app_label)s.view_%(model_name)s'] #only get is we allow here . though user have all permessions but only get permission we just provid.


#custom django model permission: 

class ViewCustomerModelPermission(permissions.BasePermission):
    def has_permission(self, request, view):
        return request.user.has_perm('store.view_history')   


----------------------------
----------------------------
store::views.py=> 
----------------------------

from rest_framework.response import Response #serializers to Json formater
from store.models import Products,Collections,OrderItems,Review,Cart,CartItem,Customers
from store.serializers import ProductSerializer,CollectionsSerializer,ReviewSerializer,CartSerializer,CartItemSerializer,AddCartItemSerializer,UpdateCartItemSerializer,CustomerSerializer
from django.db.models import Count



from rest_framework.viewsets import ModelViewSet
from django_filters.rest_framework import DjangoFilterBackend# filter easyly with any Db.coloumn like price ...
from rest_framework.filters import SearchFilter,OrderingFilter # for search,sorting -> product 
from rest_framework.pagination import PageNumberPagination #paginations
from .filters import ProductFilter 
from store.paginations import DefaultPagination #cutom paginations.

#import for cart:
from rest_framework.mixins import CreateModelMixin,RetrieveModelMixin,ListModelMixin,DestroyModelMixin,UpdateModelMixin
from rest_framework.viewsets import GenericViewSet
from .permissions import IsAdminOrReadOnly

class ProductViewSet(ModelViewSet):

    queryset = Products.objects.all()
    serializer_class = ProductSerializer

    #for filter: =>-------------------------
    filter_backends = [DjangoFilterBackend,SearchFilter,OrderingFilter]
    # pagination_class = PageNumberPagination
    pagination_class = DefaultPagination  #custom paginations
    # filterset_fields = ['collections_id']
    filterset_class = ProductFilter #import form custom file.
    search_fields  = ['title', 'describtion'] #search box working with those fields.
    ordering_fields = ['unit_price','last_update']
    permission_classes = [IsAdminOrReadOnly]



    def get_serializer_context(self): #for serializer extra variable /mehtod to send to serializer
        return {'request':self.request}
    
    def destroy(self, request, *args, **kwargs):
          if OrderItems.objects.filter(product__id=kwargs['pk']).count() > 0:  #aggregations-> count(), ORM query fn-> Count().
                return Response({"error": "product can't be delete cause in orderitem"},)
         
          return super().destroy(request, *args, **kwargs)
  




# --------------------------------collections-------------------------------------



class CollectionViewSet(ModelViewSet):
        permission_classes = [IsAdminOrReadOnly]
        
        queryset = Collections.objects.annotate(products_count=Count('products')).all()
        serializer_class = CollectionsSerializer
        

        def destroy(self, request, *args, **kwargs):
             if OrderItems.products.filter(product__id=kwargs['pk']).count() > 0:  # Changed 'collection' to 'collection'
                return Response({'error': "collections can't be deleted because order items are included"})
             
             return super().destroy(request, *args, **kwargs)
       

class ReviewViewSet(ModelViewSet):
     #cutom query : cz reviews show for every product : filter review for indivisual products.
     def get_queryset(self):
         return Review.objects.filter(product_id =self.kwargs['product_pk'])
     

     #use this method for => send data to Review serializer
     def get_context_data(self) :
         return {'product_id':self.kwargs['product_pk']}
     
     
     serializer_class = ReviewSerializer


class CartViewSet(CreateModelMixin,RetrieveModelMixin,ListModelMixin,DestroyModelMixin,GenericViewSet):
     
    #  queryset = Cart.objects.all()
     queryset = Cart.objects.prefetch_related('items__product').all() #cart -> Fk-> CartItem(related_name=items), instide cartItem Fk-> Products(product) | optimize the query
     serializer_class = CartSerializer


#show single items of cart: 
class CartItemViewSet(ModelViewSet): #tabels need , cart_id, product_id, quantity in DB.
   
    #allow http method : 
    http_method_names = ['get', 'post','patch','delete'] #declare those methods which we want to use.

    #for add cartItem use custom serializer: 
    def get_serializer_class(self):
         if self.request.method == "POST":
              return AddCartItemSerializer #use for add new cartItem.
         elif self.request.method == "PATCH":
              return UpdateCartItemSerializer
         
         return CartItemSerializer # use for get() cartItem.
    

    def get_serializer_context(self): #data collect from urls , then send to serializer 
         return {'cart_id':self.kwargs['cart_pk']}
   


     #need single cartItem hast cart_id column , so need cart_ID+ to catch  :
    def get_queryset(self):
          return CartItem.objects.\
                        filter(cart_id=self.kwargs['cart_pk']).\
                        select_related('product')



#------------------------------Customer user -> JESON WEB TOKEN-------------------------------------------

from rest_framework.decorators import action #get, put, delete ...details = retrive...
from rest_framework.permissions import IsAuthenticated,AllowAny,DjangoModelPermissions,DjangoModelPermissionsOrAnonReadOnly#permisson for users
from .permissions import FullDjangoModelPermission,ViewCustomerModelPermission #cutom permission.

class CustomerViewSet(ModelViewSet):
     queryset = Customers.objects.all()
     serializer_class = CustomerSerializer
     permission_classes = [DjangoModelPermissionsOrAnonReadOnly] #use our custom class : FullDjangoModelPermission.


     @action(detail=True, permission_classes=[ViewCustomerModelPermission]) #custom model permission
     def history(self,request,pk):#http://127.0.0.1:8000/store/customer/1/history....
          return Response('ok')
     
     @action(detail=False, methods=['GET','PUT'], permission_classes=[IsAuthenticated()])
     def me(self, request):#http://127.0.0.1:8000/store/customer/me/ -> this /me = def me(function). & request.user -> anonimus functions of classes.
          customer, created = Customers.objects.get_or_create(user_id=request.user.id) #get_or_create -> method return 2 value: cutomerID, created/not_created boolean

          if request.method == 'GET':#also show the user id , but user_id can't edit by user. that's why make the CustomerSerializer -> user_id(read_only)
               serializer = CustomerSerializer(customer)
               return Response(serializer.data)

          elif request.method == 'PUT':
               serializer = CustomerSerializer(customer, data=request.data)
               serializer.is_valid(raise_exception=True)
               serializer.save()
               return Response(serializer.data)

     




-------------------------------------------------------------------------------------------------------------
--------------------------------Order RestApi Endpoint(all)-----------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
store::urls.py=> 
----------------
from django.urls import path
from store import views
#default router show the api endpoint urls.
from rest_framework_nested import routers


app_name = 'store'


router = routers.DefaultRouter()
router.register(r'product', views.ProductViewSet, basename='product') #assertions baseName error that's why add base name
router.register(r'collection', views.CollectionViewSet)
router.register(r'cart',views.CartViewSet,basename='cart')
router.register(r'customer', views.CustomerViewSet, basename='customer')
router.register(r'order', views.OrderViewSet, basename='order')

#for retrive reviews form product use => 
product_router = routers.NestedDefaultRouter(router, r'product', lookup='product')
product_router.register(r'review', views.ReviewViewSet, basename='product-reviews')

#for retrive cartItem form cart use=> 
cart_router = routers.NestedDefaultRouter(router, r'cart', lookup='cart') # send to cart_pk to CartItemViews.
cart_router.register(r'cartItem', views.CartItemViewSet, basename='cart-items') #basename has 2 route cart-item-detials/ cart-item-list #as nested routers

urlpatterns = [] + router.urls + product_router.urls + cart_router.urls 


---------------------------
---------------------------
store::models.py-> 
---------------------------
---------------------------
from django.db import models
from uuid import uuid4 #for generate cart unique number.

#import for users links with profile: 
from django.conf import settings
#improt admin for display first_name, last_name as ordering : 
from django.contrib import admin

# Create your models here.


class Promotions(models.Model):
    describtion = models.CharField(max_length=255)
    discount = models.FloatField()


class Collections(models.Model):
    title = models.CharField(max_length=255)
    featured_product = models.ForeignKey('Products',on_delete=models.SET_NULL, null=True, related_name='+')

    def __str__(self):
        return self.title 
    
    class Meta:
        ordering = ['title']

    


class Products (models.Model):
    slug = models.SlugField()
    sku = models.CharField(max_length=10)
    title = models.CharField(max_length=255)
    describtion = models.TextField()
    unit_price = models.DecimalField(max_digits=10, decimal_places=2) 
    inventory = models.IntegerField()
    last_update = models.DateTimeField(auto_now=True)
    collections = models.ForeignKey(Collections,on_delete=models.PROTECT,related_name='products') # if want to delete Collections , Before must be delete Products .
    promotions = models.ManyToManyField(Promotions)

    def __str__(self) -> str:
        return self.title
    
    class Meta: 
        ordering = ['title']




# class Customers(models.Model):
#     MEMBERSHIP_BRONZE = 'B'
#     MEMBERSHIP_SLIVER = 'S'
#     MEMBERSHIP_GOLD = 'G'
#     MEMBERSHIP_CHOICE = [
#     ('MEMBERSHIP_BRONZE','Bronze'),
#     ('MEMBERSHIP_SLIVER','Silver'),
#     ('MEMBERSHIP_GOLD','Gold'),
#     ]

#     first_name = models.CharField(max_length=255)
#     last_name = models.CharField(max_length=255)
#     email = models.EmailField(unique=True)
#     phone = models.IntegerField()
#     brith_date = models.DateField(null=True)
#     membership = models.CharField(max_length=17, choices=MEMBERSHIP_CHOICE, default=MEMBERSHIP_BRONZE)
#     # orders = models.ManyToManyField(Order)
#     #Link to the user Model: 
#     user = models.OneToOneField(settings.AUTH_USER_MODEL,on_delete=models.CASCADE)


#     # def __str__(self):
#     #     return f"{self.first_name} {self.last_name }"
    

#     #this 2 functions pass to admin.py=> 
#     @admin.display(ordering='user__first_name')
#     def first_name(self):
#         return self.user.first_name
    
#     @admin.display(ordering='user__last_name')
#     def last_name(self):
#         return self.user.last_name
    
    
#     def get_order_count(self):
#         return self.order_set.count()


#     class Meta:
#         ordering = ['user__first_name', 'user__last_name']



class Customers(models.Model):
    MEMBERSHIP_BRONZE = 'B'
    MEMBERSHIP_SILVER = 'S'
    MEMBERSHIP_GOLD = 'G'
    MEMBERSHIP_CHOICES = [
        ('MEMBERSHIP_BRONZE', 'Bronze'),
        ('MEMBERSHIP_SILVER', 'Silver'),
        ('MEMBERSHIP_GOLD', 'Gold'),
    ]

    first_name = models.CharField(max_length=255)
    last_name = models.CharField(max_length=255)
    email = models.EmailField(unique=True)
    phone = models.IntegerField(null=True,blank=True)
    birth_date = models.DateField(null=True)
    membership = models.CharField(max_length=17, choices=MEMBERSHIP_CHOICES, default=MEMBERSHIP_BRONZE)
    user = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)

    @admin.display(ordering='user__first_name')
    def first_name(self):
        return self.user.first_name
    
    @admin.display(ordering='user__last_name')
    def last_name(self):
        return self.user.last_name
    
    def get_order_count(self):
        return self.order_set.count()

    class Meta:
        ordering = ['user__first_name', 'user__last_name']


        #custom model permission: 
        permissions = [('view_history', 'Can view history')]
        #then run >>> python manage.py makemigrations, migrate...


class Order(models.Model):
    PAYMENT_STATUS_PENDING = 'P'
    PAYMENT_STATUS_COMPLETE = 'C'
    PAYMENT_STATUS_FAILD = 'F'
    PAYMENT_STATUS_CHOICE = [
        ('PAYMENT_STATUS_PENDING','P'),
        ('PAYMENT_STATUS_COMPLETE','C'),
        ('PAYMENT_STATUS_FAILD','F'),
    ]
    place_order = models.DateTimeField(auto_now_add=True)
    payment_status = models.CharField(
    max_length=23, choices=PAYMENT_STATUS_CHOICE, default=PAYMENT_STATUS_PENDING
    )

    customers = models.ForeignKey(Customers,on_delete=models.PROTECT) #if accidently delete the Customers , we don't delete the order .

    class Meta: 
        permissions=[
            ('cancel_order', 'Can cancel Order')
        ]


class OrderItems(models.Model):
    order = models.ForeignKey(Order,on_delete=models.PROTECT, related_name='items')
    products = models.ForeignKey(Products,on_delete=models.PROTECT, related_name='orderItems')
    quantity = models.PositiveSmallIntegerField()
    unit_price = models.DecimalField(max_digits=6,decimal_places=2)

class Cart(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid4)
    created_at = models.DateTimeField(auto_now_add=True)

class Address(models.Model):
    street = models.CharField(max_length=255)  # Corrected max_length
    city = models.CharField(max_length=255)  
    

    #one to one relationship
    Customers = models.OneToOneField(Customers,on_delete=models.CASCADE, primary_key=True ) 

class CartItem(models.Model):
    cart = models.ForeignKey(Cart,on_delete=models.CASCADE, related_name='items') #
    product = models.ForeignKey(Products,on_delete=models.CASCADE)
    quantity = models.PositiveSmallIntegerField()

    unique_together = [['cart','products']] #for unique generated....



class Review(models.Model):
    product = models.ForeignKey(Products,on_delete=models.CASCADE, related_name='review')
    name = models.CharField(max_length=255)
    describtion = models.TextField()
    date = models.DateField(auto_now_add=True)
---------------------------
---------------------------
store::serializers.py-> 
---------------------------
---------------------------
from decimal import Decimal
from rest_framework import serializers
from store.models import Products,Collections,Review,Cart,CartItem,Customers,Order,OrderItems

class ProductSerializer(serializers.ModelSerializer):
    

    class Meta : 
        model = Products
        fields = ['title', 'price', 'collections','price_with_tax','inventory','describtion'] #first search fields form model , if not find . then search => price , collections, tax_with price

  
    price = serializers.DecimalField(max_digits=6, decimal_places=2, source='unit_price') #custome name price => comes from unit_prime -> product(model)
    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')

    def calculate_tax(self, product:Products):
        return product.unit_price * Decimal(1.1)



class CollectionsSerializer(serializers.ModelSerializer):
    products_count = serializers.IntegerField(read_only=True)  # Add this line

    class Meta: 
        model = Collections
        fields = ['id', 'title', 'products_count']

        


class ReviewSerializer(serializers.ModelSerializer):

    class Meta: 
        model = Review
        fields = ['id', 'date','name', 'describtion','product']

    #Receive data from context method form views.Reveiws (product_id, reviews_also )
    def create(self,validated_data):
        product_id = self.context ['product_id']
        return Review.objects.create(product_id=product_id,**validated_data)




#Cart take cartItems from CartItem serializers (parent - cart , child - cartItem):----------------------------

class SimpleProductSerializer(serializers.ModelSerializer):

    class Meta:
        model = Products
        fields = ['pk', 'title','unit_price']


class CartItemSerializer(serializers.ModelSerializer):
    product = SimpleProductSerializer() 
    total_price = serializers.SerializerMethodField()

    def get_total_price(self, cart_item: CartItem):
        return cart_item.quantity * cart_item.product.unit_price

    class Meta:
        model = CartItem
        fields = ['id', 'product', 'quantity', 'total_price']


class AddCartItemSerializer(serializers.ModelSerializer):
    product_id = serializers.IntegerField()

    class Meta:
        model = CartItem 
        fields = ['id','product_id','quantity'] #those field get from DB . if need extra data in varibale then we use self.request -> get data from url through get_context(self.kwagrs['paramsName-which get from urls/users']) for serializer.

    #data validation which get from url/users: if user input wrong product_id then => 
    def validate_product_id(self,value):
        if not Products.objects.filter(pk=value).exists():
            raise serializers.ValidationError('No Product Fount with the given ID')
        return value
    
    def save(self, **kwargs): #*** in serializer can't get params from urls , that's why use get_context() method in views to pass data into serializer.
        #in views we are using => serializer.is_validate():  -> serializer.save() 
        cart_id = self.context['cart_id'] #get from  views.context(method)
        product_id = self.validated_data['product_id'] #get from  urls
        quantity = self.validated_data['quantity'] #get from  urls

        try:
            cart_item = CartItem.objects.get(cart_id=cart_id, product_id=product_id)  #if get cart item then just update cartItem. and increase the quantity.
            cart_item.quantity += quantity
            cart_item.save()
            self.instance = cart_item#if Model get any data then update and return instance
        except CartItem.DoesNotExist:
            product = Products.objects.get(pk=product_id)
            self.instance = CartItem.objects.create(cart_id=cart_id, product=product, quantity=quantity)#if not found any cartItem then create new Item
             #  or user => 
             #  self.instance = CartItem.objects.create(cart_id=cart_id, **self.validated_data)
        return self.instance #if model not get any data then create new instance then return to db.


class UpdateCartItemSerializer(serializers.ModelSerializer):

    class Meta : 
        model = CartItem 
        fields = ['quantity']

        




class CartSerializer(serializers.ModelSerializer):
    id = serializers.UUIDField(read_only=True)
    items = CartItemSerializer(many=True, read_only=True )  # Set read_only=True
    total_price = serializers.SerializerMethodField()

    def get_total_price(self,cart:Cart):
        return sum([item.quantity * item.product.unit_price for item in cart.items.all()]) #most important Line.

    class Meta:
        model = Cart
        fields = ['id', 'items', 'total_price']



# ----------------------------------Customer Serializer-------------------------------------------------------

class CustomerSerializer(serializers.ModelSerializer):
    user_id = serializers.IntegerField(read_only=True)

    class Meta: 
        model = Customers
        fields = ['id', 'user_id', 'phone', 'email', 'birth_date', 'membership']


# ----------------------------------OrderItem Serializer-------------------------------------------------------

class OrderItemSerializer(serializers.ModelSerializer):

    class Meta: 
        model = OrderItems
        fields = ['id', 'products', 'unit_price', 'quantity']



# ----------------------------------Order Serializer-------------------------------------------------------

class OrderSerializer(serializers.ModelSerializer):

    items = OrderItemSerializer(many=True)

    class Meta:
        model = Order
        fields = ['id','payment_status', 'customers', 'place_order','items' ]

---------------------------
---------------------------
store::views.py=> 
---------------------------
---------------------------

from rest_framework.response import Response #serializers to Json formater
from store.models import Products,Collections,OrderItems,Review,Cart,CartItem,Customers,Order, OrderItems
from store.serializers import ProductSerializer,CollectionsSerializer,ReviewSerializer,CartSerializer,CartItemSerializer,AddCartItemSerializer,UpdateCartItemSerializer,CustomerSerializer, OrderSerializer
from django.db.models import Count



from rest_framework.viewsets import ModelViewSet
from django_filters.rest_framework import DjangoFilterBackend# filter easyly with any Db.coloumn like price ...
from rest_framework.filters import SearchFilter,OrderingFilter # for search,sorting -> product 
from rest_framework.pagination import PageNumberPagination #paginations
from .filters import ProductFilter 
from store.paginations import DefaultPagination #cutom paginations.

#import for cart:
from rest_framework.mixins import CreateModelMixin,RetrieveModelMixin,ListModelMixin,DestroyModelMixin,UpdateModelMixin
from rest_framework.viewsets import GenericViewSet
from .permissions import IsAdminOrReadOnly

class ProductViewSet(ModelViewSet):

    queryset = Products.objects.all()
    serializer_class = ProductSerializer

    #for filter: =>-------------------------
    filter_backends = [DjangoFilterBackend,SearchFilter,OrderingFilter]
    # pagination_class = PageNumberPagination
    pagination_class = DefaultPagination  #custom paginations
    # filterset_fields = ['collections_id']
    filterset_class = ProductFilter #import form custom file.
    search_fields  = ['title', 'describtion'] #search box working with those fields.
    ordering_fields = ['unit_price','last_update']
    permission_classes = [IsAdminOrReadOnly]



    def get_serializer_context(self): #for serializer extra variable /mehtod to send to serializer
        return {'request':self.request}
    
    def destroy(self, request, *args, **kwargs):
          if OrderItems.objects.filter(product__id=kwargs['pk']).count() > 0:  #aggregations-> count(), ORM query fn-> Count().
                return Response({"error": "product can't be delete cause in orderitem"},)
         
          return super().destroy(request, *args, **kwargs)
  




# --------------------------------collections-------------------------------------



class CollectionViewSet(ModelViewSet):
        permission_classes = [IsAdminOrReadOnly]
        
        queryset = Collections.objects.annotate(products_count=Count('products')).all()
        serializer_class = CollectionsSerializer
        

        def destroy(self, request, *args, **kwargs):
             if OrderItems.products.filter(product__id=kwargs['pk']).count() > 0:  # Changed 'collection' to 'collection'
                return Response({'error': "collections can't be deleted because order items are included"})
             
             return super().destroy(request, *args, **kwargs)
       

class ReviewViewSet(ModelViewSet):
     #cutom query : cz reviews show for every product : filter review for indivisual products.
     def get_queryset(self):
         return Review.objects.filter(product_id =self.kwargs['product_pk'])
     

     #use this method for => send data to Review serializer
     def get_context_data(self) :
         return {'product_id':self.kwargs['product_pk']}
     
     
     serializer_class = ReviewSerializer


class CartViewSet(CreateModelMixin,RetrieveModelMixin,ListModelMixin,DestroyModelMixin,GenericViewSet):
     
    #  queryset = Cart.objects.all()
     queryset = Cart.objects.prefetch_related('items__product').all() #cart -> Fk-> CartItem(related_name=items), instide cartItem Fk-> Products(product) | optimize the query
     serializer_class = CartSerializer


#show single items of cart: 
class CartItemViewSet(ModelViewSet): #tabels need , cart_id, product_id, quantity in DB.
   
    #allow http method : 
    http_method_names = ['get', 'post','patch','delete'] #declare those methods which we want to use.

    #for add cartItem use custom serializer: 
    def get_serializer_class(self):
         if self.request.method == "POST":
              return AddCartItemSerializer #use for add new cartItem.
         elif self.request.method == "PATCH":
              return UpdateCartItemSerializer
         
         return CartItemSerializer # use for get() cartItem.
    

    def get_serializer_context(self): #data collect from urls , then send to serializer 
         return {'cart_id':self.kwargs['cart_pk']}
   


     #need single cartItem hast cart_id column , so need cart_ID+ to catch  :
    def get_queryset(self):
          return CartItem.objects.\
                        filter(cart_id=self.kwargs['cart_pk']).\
                        select_related('product')



#------------------------------Customer user -> JESON WEB TOKEN-------------------------------------------

from rest_framework.decorators import action #get, put, delete ...details = retrive...
from rest_framework.permissions import IsAuthenticated,AllowAny,DjangoModelPermissions,DjangoModelPermissionsOrAnonReadOnly#permisson for users
from .permissions import FullDjangoModelPermission,ViewCustomerModelPermission #cutom permission.

class CustomerViewSet(ModelViewSet):
     queryset = Customers.objects.all()
     serializer_class = CustomerSerializer
     permission_classes = [DjangoModelPermissionsOrAnonReadOnly] #use our custom class : FullDjangoModelPermission.


     @action(detail=True, permission_classes=[ViewCustomerModelPermission]) #custom model permission
     def history(self,request,pk):#http://127.0.0.1:8000/store/customer/1/history....
          return Response('ok')
     
     @action(detail=False, methods=['GET','PUT'], permission_classes=[IsAuthenticated()])
     def me(self, request):#http://127.0.0.1:8000/store/customer/me/ -> this /me = def me(function). & request.user -> anonimus functions of classes.
          customer, created = Customers.objects.get_or_create(user_id=request.user.id) #get_or_create -> method return 2 value: cutomerID, created/not_created boolean

          if request.method == 'GET':#also show the user id , but user_id can't edit by user. that's why make the CustomerSerializer -> user_id(read_only)
               serializer = CustomerSerializer(customer)
               return Response(serializer.data)

          elif request.method == 'PUT':
               serializer = CustomerSerializer(customer, data=request.data)
               serializer.is_valid(raise_exception=True)
               serializer.save()
               return Response(serializer.data)



# --------------------------------------order viewset----------------------------------------------

class OrderViewSet(ModelViewSet):

     queryset = Order.objects.all()
     serializer_class = OrderSerializer
     


---------------------------
---------------------------


-------------------------------------------------------------------------------------------------------------
------------------------------------------Permission for order can see only stuff-------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
#if allow only stuff can see order then , admin have to give the permission to the user is staff, only they can log in 
other normal user can't log in .....

-------------------------
-------------------------
store::urls.py-> 
-------------------------
-------------------------
from django.urls import path
from store import views
#default router show the api endpoint urls.
from rest_framework_nested import routers


app_name = 'store'


router = routers.DefaultRouter()
router.register(r'product', views.ProductViewSet, basename='product') #assertions baseName error that's why add base name
router.register(r'collection', views.CollectionViewSet)
router.register(r'cart',views.CartViewSet,basename='cart')
router.register(r'customer', views.CustomerViewSet, basename='customer')
router.register(r'order', views.OrderViewSet, basename='order')

#for retrive reviews form product use => 
product_router = routers.NestedDefaultRouter(router, r'product', lookup='product')
product_router.register(r'review', views.ReviewViewSet, basename='product-reviews')

#for retrive cartItem form cart use=> 
cart_router = routers.NestedDefaultRouter(router, r'cart', lookup='cart') # send to cart_pk to CartItemViews.
cart_router.register(r'cartItem', views.CartItemViewSet, basename='cart-items') #basename has 2 route cart-item-detials/ cart-item-list #as nested routers

urlpatterns = [] + router.urls + product_router.urls + cart_router.urls 

-------------------------
-------------------------
store::views.py=> 
-------------------------
-------------------------

from rest_framework.response import Response #serializers to Json formater
from store.models import Products,Collections,OrderItems,Review,Cart,CartItem,Customers,Order, OrderItems
from store.serializers import ProductSerializer,CollectionsSerializer,ReviewSerializer,CartSerializer,CartItemSerializer,AddCartItemSerializer,UpdateCartItemSerializer,CustomerSerializer, OrderSerializer
from django.db.models import Count



from rest_framework.viewsets import ModelViewSet
from django_filters.rest_framework import DjangoFilterBackend# filter easyly with any Db.coloumn like price ...
from rest_framework.filters import SearchFilter,OrderingFilter # for search,sorting -> product 
from rest_framework.pagination import PageNumberPagination #paginations
from .filters import ProductFilter 
from store.paginations import DefaultPagination #cutom paginations.

#import for cart:
from rest_framework.mixins import CreateModelMixin,RetrieveModelMixin,ListModelMixin,DestroyModelMixin,UpdateModelMixin
from rest_framework.viewsets import GenericViewSet
from .permissions import IsAdminOrReadOnly

class ProductViewSet(ModelViewSet):

    queryset = Products.objects.all()
    serializer_class = ProductSerializer

    #for filter: =>-------------------------
    filter_backends = [DjangoFilterBackend,SearchFilter,OrderingFilter]
    # pagination_class = PageNumberPagination
    pagination_class = DefaultPagination  #custom paginations
    # filterset_fields = ['collections_id']
    filterset_class = ProductFilter #import form custom file.
    search_fields  = ['title', 'describtion'] #search box working with those fields.
    ordering_fields = ['unit_price','last_update']
    permission_classes = [IsAdminOrReadOnly]



    def get_serializer_context(self): #for serializer extra variable /mehtod to send to serializer
        return {'request':self.request}
    
    def destroy(self, request, *args, **kwargs):
          if OrderItems.objects.filter(product__id=kwargs['pk']).count() > 0:  #aggregations-> count(), ORM query fn-> Count().
                return Response({"error": "product can't be delete cause in orderitem"},)
         
          return super().destroy(request, *args, **kwargs)
  




# --------------------------------collections-------------------------------------



class CollectionViewSet(ModelViewSet):
        permission_classes = [IsAdminOrReadOnly]
        
        queryset = Collections.objects.annotate(products_count=Count('products')).all()
        serializer_class = CollectionsSerializer
        

        def destroy(self, request, *args, **kwargs):
             if OrderItems.products.filter(product__id=kwargs['pk']).count() > 0:  # Changed 'collection' to 'collection'
                return Response({'error': "collections can't be deleted because order items are included"})
             
             return super().destroy(request, *args, **kwargs)
       

class ReviewViewSet(ModelViewSet):
     #cutom query : cz reviews show for every product : filter review for indivisual products.
     def get_queryset(self):
         return Review.objects.filter(product_id =self.kwargs['product_pk'])
     

     #use this method for => send data to Review serializer
     def get_context_data(self) :
         return {'product_id':self.kwargs['product_pk']}
     
     
     serializer_class = ReviewSerializer


class CartViewSet(CreateModelMixin,RetrieveModelMixin,ListModelMixin,DestroyModelMixin,GenericViewSet):
     
    #  queryset = Cart.objects.all()
     queryset = Cart.objects.prefetch_related('items__product').all() #cart -> Fk-> CartItem(related_name=items), instide cartItem Fk-> Products(product) | optimize the query
     serializer_class = CartSerializer


#show single items of cart: 
class CartItemViewSet(ModelViewSet): #tabels need , cart_id, product_id, quantity in DB.
   
    #allow http method : 
    http_method_names = ['get', 'post','patch','delete'] #declare those methods which we want to use.

    #for add cartItem use custom serializer: 
    def get_serializer_class(self):
         if self.request.method == "POST":
              return AddCartItemSerializer #use for add new cartItem.
         elif self.request.method == "PATCH":
              return UpdateCartItemSerializer
         
         return CartItemSerializer # use for get() cartItem.
    

    def get_serializer_context(self): #data collect from urls , then send to serializer 
         return {'cart_id':self.kwargs['cart_pk']}
   


     #need single cartItem hast cart_id column , so need cart_ID+ to catch  :
    def get_queryset(self):
          return CartItem.objects.\
                        filter(cart_id=self.kwargs['cart_pk']).\
                        select_related('product')



#------------------------------Customer user -> JESON WEB TOKEN-------------------------------------------

from rest_framework.decorators import action #get, put, delete ...details = retrive...
from rest_framework.permissions import IsAuthenticated,AllowAny,DjangoModelPermissions,DjangoModelPermissionsOrAnonReadOnly#permisson for users
from .permissions import FullDjangoModelPermission,ViewCustomerModelPermission #cutom permission.

class CustomerViewSet(ModelViewSet):
     queryset = Customers.objects.all()
     serializer_class = CustomerSerializer
     permission_classes = [DjangoModelPermissionsOrAnonReadOnly] #use our custom class : FullDjangoModelPermission.


     @action(detail=True, permission_classes=[ViewCustomerModelPermission]) #custom model permission
     def history(self,request,pk):#http://127.0.0.1:8000/store/customer/1/history....
          return Response('ok')
     
     @action(detail=False, methods=['GET','PUT'], permission_classes=[IsAuthenticated()])
     def me(self, request):#http://127.0.0.1:8000/store/customer/me/ -> this /me = def me(function). & request.user -> anonimus functions of classes.
          customer, created = Customers.objects.get_or_create(user_id=request.user.id) #get_or_create -> method return 2 value: cutomerID, created/not_created boolean

          if request.method == 'GET':#also show the user id , but user_id can't edit by user. that's why make the CustomerSerializer -> user_id(read_only)
               serializer = CustomerSerializer(customer)
               return Response(serializer.data)

          elif request.method == 'PUT':
               serializer = CustomerSerializer(customer, data=request.data)
               serializer.is_valid(raise_exception=True)
               serializer.save()
               return Response(serializer.data)



# --------------------------------------order viewset----------------------------------------------

class OrderViewSet(ModelViewSet):

     
     queryset = Order.objects.all()
     serializer_class = OrderSerializer
     permission_classes = [IsAuthenticated]

     def get_queryset(self):
          user = self.request.user

          if user.is_staff: #only stuff see the order
               return Order.objects.all()
          (customer, created) = Customers.objects.only('id').get_or_create(user_id=user.id)
          return Order.objects.filter(customers_id=customer)

-------------------------
-------------------------
store::models.py=> 
-------------------------
-------------------------
from django.db import models
from uuid import uuid4 #for generate cart unique number.

#import for users links with profile: 
from django.conf import settings
#improt admin for display first_name, last_name as ordering : 
from django.contrib import admin

# Create your models here.


class Promotions(models.Model):
    describtion = models.CharField(max_length=255)
    discount = models.FloatField()


class Collections(models.Model):
    title = models.CharField(max_length=255)
    featured_product = models.ForeignKey('Products',on_delete=models.SET_NULL, null=True, related_name='+')

    def __str__(self):
        return self.title 
    
    class Meta:
        ordering = ['title']

    


class Products (models.Model):
    slug = models.SlugField()
    sku = models.CharField(max_length=10)
    title = models.CharField(max_length=255)
    describtion = models.TextField()
    unit_price = models.DecimalField(max_digits=10, decimal_places=2) 
    inventory = models.IntegerField()
    last_update = models.DateTimeField(auto_now=True)
    collections = models.ForeignKey(Collections,on_delete=models.PROTECT,related_name='products') # if want to delete Collections , Before must be delete Products .
    promotions = models.ManyToManyField(Promotions)

    def __str__(self) -> str:
        return self.title
    
    class Meta: 
        ordering = ['title']




# class Customers(models.Model):
#     MEMBERSHIP_BRONZE = 'B'
#     MEMBERSHIP_SLIVER = 'S'
#     MEMBERSHIP_GOLD = 'G'
#     MEMBERSHIP_CHOICE = [
#     ('MEMBERSHIP_BRONZE','Bronze'),
#     ('MEMBERSHIP_SLIVER','Silver'),
#     ('MEMBERSHIP_GOLD','Gold'),
#     ]

#     first_name = models.CharField(max_length=255)
#     last_name = models.CharField(max_length=255)
#     email = models.EmailField(unique=True)
#     phone = models.IntegerField()
#     brith_date = models.DateField(null=True)
#     membership = models.CharField(max_length=17, choices=MEMBERSHIP_CHOICE, default=MEMBERSHIP_BRONZE)
#     # orders = models.ManyToManyField(Order)
#     #Link to the user Model: 
#     user = models.OneToOneField(settings.AUTH_USER_MODEL,on_delete=models.CASCADE)


#     # def __str__(self):
#     #     return f"{self.first_name} {self.last_name }"
    

#     #this 2 functions pass to admin.py=> 
#     @admin.display(ordering='user__first_name')
#     def first_name(self):
#         return self.user.first_name
    
#     @admin.display(ordering='user__last_name')
#     def last_name(self):
#         return self.user.last_name
    
    
#     def get_order_count(self):
#         return self.order_set.count()


#     class Meta:
#         ordering = ['user__first_name', 'user__last_name']



class Customers(models.Model):
    MEMBERSHIP_BRONZE = 'B'
    MEMBERSHIP_SILVER = 'S'
    MEMBERSHIP_GOLD = 'G'
    MEMBERSHIP_CHOICES = [
        ('MEMBERSHIP_BRONZE', 'Bronze'),
        ('MEMBERSHIP_SILVER', 'Silver'),
        ('MEMBERSHIP_GOLD', 'Gold'),
    ]

    first_name = models.CharField(max_length=255)
    last_name = models.CharField(max_length=255)
    email = models.EmailField(unique=True)
    phone = models.IntegerField(null=True,blank=True)
    birth_date = models.DateField(null=True)
    membership = models.CharField(max_length=17, choices=MEMBERSHIP_CHOICES, default=MEMBERSHIP_BRONZE)
    user = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)

    @admin.display(ordering='user__first_name')
    def first_name(self):
        return self.user.first_name
    
    @admin.display(ordering='user__last_name')
    def last_name(self):
        return self.user.last_name
    
    def get_order_count(self):
        return self.order_set.count()

    class Meta:
        ordering = ['user__first_name', 'user__last_name']


        #custom model permission: 
        permissions = [('view_history', 'Can view history')]
        #then run >>> python manage.py makemigrations, migrate...


class Order(models.Model):
    PAYMENT_STATUS_PENDING = 'P'
    PAYMENT_STATUS_COMPLETE = 'C'
    PAYMENT_STATUS_FAILD = 'F'
    PAYMENT_STATUS_CHOICE = [
        ('PAYMENT_STATUS_PENDING','P'),
        ('PAYMENT_STATUS_COMPLETE','C'),
        ('PAYMENT_STATUS_FAILD','F'),
    ]
    place_order = models.DateTimeField(auto_now_add=True)
    payment_status = models.CharField(
    max_length=23, choices=PAYMENT_STATUS_CHOICE, default=PAYMENT_STATUS_PENDING
    )

    customers = models.ForeignKey(Customers, on_delete=models.PROTECT) #if accidently delete the Customers , we don't delete the order .

    class Meta: 
        permissions=[
            ('cancel_order', 'Can cancel Order')
        ]


class OrderItems(models.Model):
    order = models.ForeignKey(Order,on_delete=models.PROTECT, related_name='items')
    products = models.ForeignKey(Products,on_delete=models.PROTECT, related_name='orderItems')
    quantity = models.PositiveSmallIntegerField()
    unit_price = models.DecimalField(max_digits=6,decimal_places=2)

class Cart(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid4)
    created_at = models.DateTimeField(auto_now_add=True)

class Address(models.Model):
    street = models.CharField(max_length=255)  # Corrected max_length
    city = models.CharField(max_length=255)  
    

    #one to one relationship
    Customers = models.OneToOneField(Customers,on_delete=models.CASCADE, primary_key=True ) 

class CartItem(models.Model):
    cart = models.ForeignKey(Cart,on_delete=models.CASCADE, related_name='items') #
    product = models.ForeignKey(Products,on_delete=models.CASCADE)
    quantity = models.PositiveSmallIntegerField()

    unique_together = [['cart','products']] #for unique generated....



class Review(models.Model):
    product = models.ForeignKey(Products,on_delete=models.CASCADE, related_name='review')
    name = models.CharField(max_length=255)
    describtion = models.TextField()
    date = models.DateField(auto_now_add=True)
-------------------------
-------------------------
serializer.py=> 
-------------------------
-------------------------
from decimal import Decimal
from rest_framework import serializers
from store.models import Products,Collections,Review,Cart,CartItem,Customers,Order,OrderItems

class ProductSerializer(serializers.ModelSerializer):
    

    class Meta : 
        model = Products
        fields = ['title', 'price', 'collections','price_with_tax','inventory','describtion'] #first search fields form model , if not find . then search => price , collections, tax_with price

  
    price = serializers.DecimalField(max_digits=6, decimal_places=2, source='unit_price') #custome name price => comes from unit_prime -> product(model)
    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')

    def calculate_tax(self, product:Products):
        return product.unit_price * Decimal(1.1)



class CollectionsSerializer(serializers.ModelSerializer):
    products_count = serializers.IntegerField(read_only=True)  # Add this line

    class Meta: 
        model = Collections
        fields = ['id', 'title', 'products_count']

        


class ReviewSerializer(serializers.ModelSerializer):

    class Meta: 
        model = Review
        fields = ['id', 'date','name', 'describtion','product']

    #Receive data from context method form views.Reveiws (product_id, reviews_also )
    def create(self,validated_data):
        product_id = self.context ['product_id']
        return Review.objects.create(product_id=product_id,**validated_data)




#Cart take cartItems from CartItem serializers (parent - cart , child - cartItem):----------------------------

class SimpleProductSerializer(serializers.ModelSerializer):

    class Meta:
        model = Products
        fields = ['pk', 'title','unit_price']


class CartItemSerializer(serializers.ModelSerializer):
    product = SimpleProductSerializer() 
    total_price = serializers.SerializerMethodField()

    def get_total_price(self, cart_item: CartItem):
        return cart_item.quantity * cart_item.product.unit_price

    class Meta:
        model = CartItem
        fields = ['id', 'product', 'quantity', 'total_price']


class AddCartItemSerializer(serializers.ModelSerializer):
    product_id = serializers.IntegerField()

    class Meta:
        model = CartItem 
        fields = ['id','product_id','quantity'] #those field get from DB . if need extra data in varibale then we use self.request -> get data from url through get_context(self.kwagrs['paramsName-which get from urls/users']) for serializer.

    #data validation which get from url/users: if user input wrong product_id then => 
    def validate_product_id(self,value):
        if not Products.objects.filter(pk=value).exists():
            raise serializers.ValidationError('No Product Fount with the given ID')
        return value
    
    def save(self, **kwargs): #*** in serializer can't get params from urls , that's why use get_context() method in views to pass data into serializer.
        #in views we are using => serializer.is_validate():  -> serializer.save() 
        cart_id = self.context['cart_id'] #get from  views.context(method)
        product_id = self.validated_data['product_id'] #get from  urls
        quantity = self.validated_data['quantity'] #get from  urls

        try:
            cart_item = CartItem.objects.get(cart_id=cart_id, product_id=product_id)  #if get cart item then just update cartItem. and increase the quantity.
            cart_item.quantity += quantity
            cart_item.save()
            self.instance = cart_item#if Model get any data then update and return instance
        except CartItem.DoesNotExist:
            product = Products.objects.get(pk=product_id)
            self.instance = CartItem.objects.create(cart_id=cart_id, product=product, quantity=quantity)#if not found any cartItem then create new Item
             #  or user => 
             #  self.instance = CartItem.objects.create(cart_id=cart_id, **self.validated_data)
        return self.instance #if model not get any data then create new instance then return to db.


class UpdateCartItemSerializer(serializers.ModelSerializer):

    class Meta : 
        model = CartItem 
        fields = ['quantity']

        




class CartSerializer(serializers.ModelSerializer):
    id = serializers.UUIDField(read_only=True)
    items = CartItemSerializer(many=True, read_only=True )  # Set read_only=True
    total_price = serializers.SerializerMethodField()

    def get_total_price(self,cart:Cart):
        return sum([item.quantity * item.product.unit_price for item in cart.items.all()]) #most important Line.

    class Meta:
        model = Cart
        fields = ['id', 'items', 'total_price']



# ----------------------------------Customer Serializer-------------------------------------------------------

class CustomerSerializer(serializers.ModelSerializer):
    user_id = serializers.IntegerField(read_only=True)

    class Meta: 
        model = Customers
        fields = ['id', 'user_id', 'phone', 'email', 'birth_date', 'membership']


# ----------------------------------OrderItem Serializer-------------------------------------------------------

class OrderItemSerializer(serializers.ModelSerializer):

    class Meta: 
        model = OrderItems
        fields = ['id', 'products', 'unit_price', 'quantity']



# ----------------------------------Order Serializer-------------------------------------------------------

class OrderSerializer(serializers.ModelSerializer):

    items = OrderItemSerializer(many=True)

    class Meta:
        model = Order
        fields = ['id','payment_status', 'customers', 'place_order','items' ]

-------------------------
-------------------------------------------------------------------------------------------------------------
-------------------------------------------Create Order------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
store::urls.py=> 
----------------
from django.urls import path
from store import views
#default router show the api endpoint urls.
from rest_framework_nested import routers


app_name = 'store'


router = routers.DefaultRouter()
router.register(r'product', views.ProductViewSet, basename='product') #assertions baseName error that's why add base name
router.register(r'collection', views.CollectionViewSet)
router.register(r'cart',views.CartViewSet,basename='cart')
router.register(r'customer', views.CustomerViewSet, basename='customer')
router.register(r'order', views.OrderViewSet, basename='order')

#for retrive reviews form product use => 
product_router = routers.NestedDefaultRouter(router, r'product', lookup='product')
product_router.register(r'review', views.ReviewViewSet, basename='product-reviews')

#for retrive cartItem form cart use=> 
cart_router = routers.NestedDefaultRouter(router, r'cart', lookup='cart') # send to cart_pk to CartItemViews.
cart_router.register(r'cartItem', views.CartItemViewSet, basename='cart-items') #basename has 2 route cart-item-detials/ cart-item-list #as nested routers

urlpatterns = [] + router.urls + product_router.urls + cart_router.urls 
---------------------------
---------------------------
store.views.py=> 
---------------------------

from rest_framework.response import Response #serializers to Json formater
from store.models import Products,Collections,OrderItems,Review,Cart,CartItem,Customers,Order, OrderItems
from store.serializers import ProductSerializer,CollectionsSerializer,ReviewSerializer,CartSerializer,CartItemSerializer,AddCartItemSerializer,UpdateCartItemSerializer,CustomerSerializer, OrderSerializer
from django.db.models import Count



from rest_framework.viewsets import ModelViewSet
from django_filters.rest_framework import DjangoFilterBackend# filter easyly with any Db.coloumn like price ...
from rest_framework.filters import SearchFilter,OrderingFilter # for search,sorting -> product 
from rest_framework.pagination import PageNumberPagination #paginations
from .filters import ProductFilter 
from store.paginations import DefaultPagination #cutom paginations.

#import for cart:
from rest_framework.mixins import CreateModelMixin,RetrieveModelMixin,ListModelMixin,DestroyModelMixin,UpdateModelMixin
from rest_framework.viewsets import GenericViewSet
from .permissions import IsAdminOrReadOnly

class ProductViewSet(ModelViewSet):

    queryset = Products.objects.all()
    serializer_class = ProductSerializer

    #for filter: =>-------------------------
    filter_backends = [DjangoFilterBackend,SearchFilter,OrderingFilter]
    # pagination_class = PageNumberPagination
    pagination_class = DefaultPagination  #custom paginations
    # filterset_fields = ['collections_id']
    filterset_class = ProductFilter #import form custom file.
    search_fields  = ['title', 'describtion'] #search box working with those fields.
    ordering_fields = ['unit_price','last_update']
    permission_classes = [IsAdminOrReadOnly]



    def get_serializer_context(self): #for serializer extra variable /mehtod to send to serializer
        return {'request':self.request}
    
    def destroy(self, request, *args, **kwargs):
          if OrderItems.objects.filter(product__id=kwargs['pk']).count() > 0:  #aggregations-> count(), ORM query fn-> Count().
                return Response({"error": "product can't be delete cause in orderitem"},)
         
          return super().destroy(request, *args, **kwargs)
  




# --------------------------------collections-------------------------------------



class CollectionViewSet(ModelViewSet):
        permission_classes = [IsAdminOrReadOnly]
        
        queryset = Collections.objects.annotate(products_count=Count('products')).all()
        serializer_class = CollectionsSerializer
        

        def destroy(self, request, *args, **kwargs):
             if OrderItems.products.filter(product__id=kwargs['pk']).count() > 0:  # Changed 'collection' to 'collection'
                return Response({'error': "collections can't be deleted because order items are included"})
             
             return super().destroy(request, *args, **kwargs)
       

class ReviewViewSet(ModelViewSet):
     #cutom query : cz reviews show for every product : filter review for indivisual products.
     def get_queryset(self):
         return Review.objects.filter(product_id =self.kwargs['product_pk'])
     

     #use this method for => send data to Review serializer
     def get_context_data(self) :
         return {'product_id':self.kwargs['product_pk']}
     
     
     serializer_class = ReviewSerializer


class CartViewSet(CreateModelMixin,RetrieveModelMixin,ListModelMixin,DestroyModelMixin,GenericViewSet):
     
    #  queryset = Cart.objects.all()
     queryset = Cart.objects.prefetch_related('items__product').all() #cart -> Fk-> CartItem(related_name=items), instide cartItem Fk-> Products(product) | optimize the query
     serializer_class = CartSerializer


#show single items of cart: 
class CartItemViewSet(ModelViewSet): #tabels need , cart_id, product_id, quantity in DB.
   
    #allow http method : 
    http_method_names = ['get', 'post','patch','delete'] #declare those methods which we want to use.

    #for add cartItem use custom serializer: 
    def get_serializer_class(self):
         if self.request.method == "POST":
              return AddCartItemSerializer #use for add new cartItem.
         elif self.request.method == "PATCH":
              return UpdateCartItemSerializer
         
         return CartItemSerializer # use for get() cartItem.
    

    def get_serializer_context(self): #data collect from urls , then send to serializer 
         return {'cart_id':self.kwargs['cart_pk']}
   


     #need single cartItem hast cart_id column , so need cart_ID+ to catch  :
    def get_queryset(self):
          return CartItem.objects.\
                        filter(cart_id=self.kwargs['cart_pk']).\
                        select_related('product')



#------------------------------Customer user -> JESON WEB TOKEN-------------------------------------------

from rest_framework.decorators import action #get, put, delete ...details = retrive...
from rest_framework.permissions import IsAuthenticated,AllowAny,DjangoModelPermissions,DjangoModelPermissionsOrAnonReadOnly#permisson for users
from .permissions import FullDjangoModelPermission,ViewCustomerModelPermission #cutom permission.

class CustomerViewSet(ModelViewSet):
     queryset = Customers.objects.all()
     serializer_class = CustomerSerializer
     permission_classes = [DjangoModelPermissionsOrAnonReadOnly] #use our custom class : FullDjangoModelPermission.


     @action(detail=True, permission_classes=[ViewCustomerModelPermission]) #custom model permission
     def history(self,request,pk):#http://127.0.0.1:8000/store/customer/1/history....
          return Response('ok')
     
     @action(detail=False, methods=['GET','PUT'], permission_classes=[IsAuthenticated()])
     def me(self, request):#http://127.0.0.1:8000/store/customer/me/ -> this /me = def me(function). & request.user -> anonimus functions of classes.
          customer, created = Customers.objects.get_or_create(user_id=request.user.id) #get_or_create -> method return 2 value: cutomerID, created/not_created boolean

          if request.method == 'GET':#also show the user id , but user_id can't edit by user. that's why make the CustomerSerializer -> user_id(read_only)
               serializer = CustomerSerializer(customer)
               return Response(serializer.data)

          elif request.method == 'PUT':
               serializer = CustomerSerializer(customer, data=request.data)
               serializer.is_valid(raise_exception=True)
               serializer.save()
               return Response(serializer.data)



# --------------------------------------order viewset----------------------------------------------

from .serializers import OrderSerializer,CreateOrderSerializer,OrderItemSerializer

# class OrderViewSet(ModelViewSet):

     
#      # queryset = Order.objects.all()
#      permission_classes = [IsAuthenticated]


#      def get_serializer_class(self):
#           if self.request.method == "POST":
#                return CreateOrderSerializer
#           return OrderSerializer

#      def get_serializer_context(self):
#           return {'user_id' : self.request.user.id}

#      def get_queryset(self):
#           user = self.request.user

#           if user.is_staff: #only stuff see the order
#                return Order.objects.all()
#           (customer, created) = Customers.objects.only('id').get_or_create(user_id=user.id)
#           return Order.objects.filter(customers_id=customer)


class OrderViewSet(ModelViewSet):
    permission_classes = [IsAuthenticated]

    def get_serializer_class(self):
        if self.request.method == "POST":
            return CreateOrderSerializer
        return OrderSerializer

    def get_serializer_context(self):
        return {'user_id': self.request.user.id}

    def get_queryset(self):
        user = self.request.user

        if user.is_staff:
            return Order.objects.all()

        customer, created = Customers.objects.only('id').get_or_create(user_id=user.id)
        return Order.objects.filter(customers=customer)

---------------------------
---------------------------
store::serializers.py=>
---------------------------
from decimal import Decimal
from rest_framework import serializers
from store.models import Products,Collections,Review,Cart,CartItem,Customers,Order,OrderItems

class ProductSerializer(serializers.ModelSerializer):
    

    class Meta : 
        model = Products
        fields = ['title', 'price', 'collections','price_with_tax','inventory','describtion'] #first search fields form model , if not find . then search => price , collections, tax_with price

  
    price = serializers.DecimalField(max_digits=6, decimal_places=2, source='unit_price') #custome name price => comes from unit_prime -> product(model)
    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')

    def calculate_tax(self, product:Products):
        return product.unit_price * Decimal(1.1)



class CollectionsSerializer(serializers.ModelSerializer):
    products_count = serializers.IntegerField(read_only=True)  # Add this line

    class Meta: 
        model = Collections
        fields = ['id', 'title', 'products_count']

        


class ReviewSerializer(serializers.ModelSerializer):

    class Meta: 
        model = Review
        fields = ['id', 'date','name', 'describtion','product']

    #Receive data from context method form views.Reveiws (product_id, reviews_also )
    def create(self,validated_data):
        product_id = self.context ['product_id']
        return Review.objects.create(product_id=product_id,**validated_data)




#Cart take cartItems from CartItem serializers (parent - cart , child - cartItem):----------------------------

class SimpleProductSerializer(serializers.ModelSerializer):

    class Meta:
        model = Products
        fields = ['pk', 'title','unit_price']


class CartItemSerializer(serializers.ModelSerializer):
    product = SimpleProductSerializer() 
    total_price = serializers.SerializerMethodField()

    def get_total_price(self, cart_item: CartItem):
        return cart_item.quantity * cart_item.product.unit_price

    class Meta:
        model = CartItem
        fields = ['id', 'product', 'quantity', 'total_price']


class AddCartItemSerializer(serializers.ModelSerializer):
    product_id = serializers.IntegerField()

    class Meta:
        model = CartItem 
        fields = ['id','product_id','quantity'] #those field get from DB . if need extra data in varibale then we use self.request -> get data from url through get_context(self.kwagrs['paramsName-which get from urls/users']) for serializer.

    #data validation which get from url/users: if user input wrong product_id then => 
    def validate_product_id(self,value):
        if not Products.objects.filter(pk=value).exists():
            raise serializers.ValidationError('No Product Fount with the given ID')
        return value
    
    def save(self, **kwargs): #*** in serializer can't get params from urls , that's why use get_context() method in views to pass data into serializer.
        #in views we are using => serializer.is_validate():  -> serializer.save() 
        cart_id = self.context['cart_id'] #get from  views.context(method)
        product_id = self.validated_data['product_id'] #get from  urls
        quantity = self.validated_data['quantity'] #get from  urls

        try:
            cart_item = CartItem.objects.get(cart_id=cart_id, product_id=product_id)  #if get cart item then just update cartItem. and increase the quantity.
            cart_item.quantity += quantity
            cart_item.save()
            self.instance = cart_item#if Model get any data then update and return instance
        except CartItem.DoesNotExist:
            product = Products.objects.get(pk=product_id)
            self.instance = CartItem.objects.create(cart_id=cart_id, product=product, quantity=quantity)#if not found any cartItem then create new Item
             #  or user => 
             #  self.instance = CartItem.objects.create(cart_id=cart_id, **self.validated_data)
        return self.instance #if model not get any data then create new instance then return to db.


class UpdateCartItemSerializer(serializers.ModelSerializer):

    class Meta : 
        model = CartItem 
        fields = ['quantity']

        




class CartSerializer(serializers.ModelSerializer):
    id = serializers.UUIDField(read_only=True)
    items = CartItemSerializer(many=True, read_only=True )  # Set read_only=True
    total_price = serializers.SerializerMethodField()

    def get_total_price(self,cart:Cart):
        return sum([item.quantity * item.product.unit_price for item in cart.items.all()]) #most important Line.

    class Meta:
        model = Cart
        fields = ['id', 'items', 'total_price']



# ----------------------------------Customer Serializer-------------------------------------------------------

class CustomerSerializer(serializers.ModelSerializer):
    user_id = serializers.IntegerField(read_only=True)

    class Meta: 
        model = Customers
        fields = ['id', 'user_id', 'phone', 'email', 'birth_date', 'membership']


# ----------------------------------OrderItem Serializer-------------------------------------------------------

class OrderItemSerializer(serializers.ModelSerializer):
    product = SimpleProductSerializer()

    class Meta: 
        model = OrderItems
        fields = ['id', 'product', 'unit_price', 'quantity']




# ----------------------------------Order Serializer-------------------------------------------------------

class OrderSerializer(serializers.ModelSerializer):

    items = OrderItemSerializer(many=True)

    class Meta:
        model = Order
        fields = ['id','payment_status', 'customers', 'place_order','items' ]


# class CreateOrderSerializer(serializers.Serializer):

#     cart_id = serializers.UUIDField()

#     def save(self, **kwargs):
#         print(self.validated_data['cart_id'])
#         print(self.context.get('user_id'))
#         # print(self.context['user_id'])  # Use square brackets instead of ()
#         (customer, created) = Customers.objects.get_or_create(user_id=self.context['user_id'])
#         Order.objects.create(customer=customer)


# class CreateOrderSerializer(serializers.Serializer):

#     cart_id = serializers.UUIDField()

#     def save(self, **kwargs):
#         print(self.validated_data['cart_id'])
#         user_id = self.context.get('user_id')  # Corrected line
#         print(user_id)
#         customer, created = Customers.objects.get_or_create(user_id=user_id)
#         Cart.objects.create(customer=customer)



class CreateOrderSerializer(serializers.Serializer):

    cart_id = serializers.UUIDField()

    def save(self, **kwargs):
        cart_id = self.validated_data['cart_id']
        user_id = self.context.get('user_id')

        if not user_id:
            raise serializers.ValidationError("User ID is required.")

        customer, created = Customers.objects.get_or_create(user_id=user_id)

        Order.objects.create(customers=customer)  # Assuming customers is the ForeignKey to Customers

        # You can add more logic for creating OrderItems or other related models if needed

        return Order.objects.latest('id')  # Return the newly created order

---------------------------
---------------------------
store::models.py=> 
---------------------------
---------------------------
from django.db import models
from uuid import uuid4 #for generate cart unique number.

#import for users links with profile: 
from django.conf import settings
#improt admin for display first_name, last_name as ordering : 
from django.contrib import admin

# Create your models here.


class Promotions(models.Model):
    describtion = models.CharField(max_length=255)
    discount = models.FloatField()


class Collections(models.Model):
    title = models.CharField(max_length=255)
    featured_product = models.ForeignKey('Products',on_delete=models.SET_NULL, null=True, related_name='+')

    def __str__(self):
        return self.title 
    
    class Meta:
        ordering = ['title']

    


class Products (models.Model):
    slug = models.SlugField()
    sku = models.CharField(max_length=10)
    title = models.CharField(max_length=255)
    describtion = models.TextField()
    unit_price = models.DecimalField(max_digits=10, decimal_places=2) 
    inventory = models.IntegerField()
    last_update = models.DateTimeField(auto_now=True)
    collections = models.ForeignKey(Collections,on_delete=models.PROTECT,related_name='products') # if want to delete Collections , Before must be delete Products .
    promotions = models.ManyToManyField(Promotions)

    def __str__(self) -> str:
        return self.title
    
    class Meta: 
        ordering = ['title']




# class Customers(models.Model):
#     MEMBERSHIP_BRONZE = 'B'
#     MEMBERSHIP_SLIVER = 'S'
#     MEMBERSHIP_GOLD = 'G'
#     MEMBERSHIP_CHOICE = [
#     ('MEMBERSHIP_BRONZE','Bronze'),
#     ('MEMBERSHIP_SLIVER','Silver'),
#     ('MEMBERSHIP_GOLD','Gold'),
#     ]

#     first_name = models.CharField(max_length=255)
#     last_name = models.CharField(max_length=255)
#     email = models.EmailField(unique=True)
#     phone = models.IntegerField()
#     brith_date = models.DateField(null=True)
#     membership = models.CharField(max_length=17, choices=MEMBERSHIP_CHOICE, default=MEMBERSHIP_BRONZE)
#     # orders = models.ManyToManyField(Order)
#     #Link to the user Model: 
#     user = models.OneToOneField(settings.AUTH_USER_MODEL,on_delete=models.CASCADE)


#     # def __str__(self):
#     #     return f"{self.first_name} {self.last_name }"
    

#     #this 2 functions pass to admin.py=> 
#     @admin.display(ordering='user__first_name')
#     def first_name(self):
#         return self.user.first_name
    
#     @admin.display(ordering='user__last_name')
#     def last_name(self):
#         return self.user.last_name
    
    
#     def get_order_count(self):
#         return self.order_set.count()


#     class Meta:
#         ordering = ['user__first_name', 'user__last_name']



class Customers(models.Model):
    MEMBERSHIP_BRONZE = 'B'
    MEMBERSHIP_SILVER = 'S'
    MEMBERSHIP_GOLD = 'G'
    MEMBERSHIP_CHOICES = [
        ('MEMBERSHIP_BRONZE', 'Bronze'),
        ('MEMBERSHIP_SILVER', 'Silver'),
        ('MEMBERSHIP_GOLD', 'Gold'),
    ]

    first_name = models.CharField(max_length=255)
    last_name = models.CharField(max_length=255)
    email = models.EmailField(unique=True)
    phone = models.IntegerField(null=True)
    birth_date = models.DateField(null=True)
    membership = models.CharField(max_length=17, choices=MEMBERSHIP_CHOICES, default=MEMBERSHIP_BRONZE)
    user = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)

    @admin.display(ordering='user__first_name')
    def first_name(self):
        return self.user.first_name
    
    @admin.display(ordering='user__last_name')
    def last_name(self):
        return self.user.last_name
    
    def get_order_count(self):
        return self.order_set.count()

    class Meta:
        ordering = ['user__first_name', 'user__last_name']


        #custom model permission: 
        permissions = [('view_history', 'Can view history')]
        #then run >>> python manage.py makemigrations, migrate...


class Order(models.Model):
    PAYMENT_STATUS_PENDING = 'P'
    PAYMENT_STATUS_COMPLETE = 'C'
    PAYMENT_STATUS_FAILD = 'F'
    PAYMENT_STATUS_CHOICE = [
        ('PAYMENT_STATUS_PENDING','P'),
        ('PAYMENT_STATUS_COMPLETE','C'),
        ('PAYMENT_STATUS_FAILD','F'),
    ]
    place_order = models.DateTimeField(auto_now_add=True)
    payment_status = models.CharField(
    max_length=23, choices=PAYMENT_STATUS_CHOICE, default=PAYMENT_STATUS_PENDING
    )

    customers = models.ForeignKey(Customers, on_delete=models.PROTECT) #if accidently delete the Customers , we don't delete the order .

    class Meta: 
        permissions=[
            ('cancel_order', 'Can cancel Order')
        ]


class OrderItems(models.Model):
    order = models.ForeignKey(Order,on_delete=models.PROTECT, related_name='items')
    product = models.ForeignKey(Products,on_delete=models.PROTECT, related_name='orderItems')
    quantity = models.PositiveSmallIntegerField()
    unit_price = models.DecimalField(max_digits=6,decimal_places=2)

class Cart(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid4)
    created_at = models.DateTimeField(auto_now_add=True)

class Address(models.Model):
    street = models.CharField(max_length=255)  # Corrected max_length
    city = models.CharField(max_length=255)  
    

    #one to one relationship
    Customers = models.OneToOneField(Customers,on_delete=models.CASCADE, primary_key=True ) 

class CartItem(models.Model):
    cart = models.ForeignKey(Cart,on_delete=models.CASCADE, related_name='items') #
    product = models.ForeignKey(Products,on_delete=models.CASCADE)
    quantity = models.PositiveSmallIntegerField()

    unique_together = [['cart','products']] #for unique generated....



class Review(models.Model):
    product = models.ForeignKey(Products,on_delete=models.CASCADE, related_name='review')
    name = models.CharField(max_length=255)
    describtion = models.TextField()
    date = models.DateField(auto_now_add=True)
---------------------------
---------------------------
-------------------------------------------------------------------------------------------------------------
-------------------------------------------Order RestAPi full------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
store::urls.py-> 
-----------------

from django.urls import path
from store import views
#default router show the api endpoint urls.
from rest_framework_nested import routers


app_name = 'store'


router = routers.DefaultRouter()
router.register(r'product', views.ProductViewSet, basename='product') #assertions baseName error that's why add base name
router.register(r'collection', views.CollectionViewSet)
router.register(r'cart',views.CartViewSet,basename='cart')
router.register(r'customer', views.CustomerViewSet, basename='customer')
router.register(r'order', views.OrderViewSet, basename='order')

#for retrive reviews form product use => 
product_router = routers.NestedDefaultRouter(router, r'product', lookup='product')
product_router.register(r'review', views.ReviewViewSet, basename='product-reviews')

#for retrive cartItem form cart use=> 
cart_router = routers.NestedDefaultRouter(router, r'cart', lookup='cart') # send to cart_pk to CartItemViews.
cart_router.register(r'cartItem', views.CartItemViewSet, basename='cart-items') #basename has 2 route cart-item-detials/ cart-item-list #as nested routers

urlpatterns = [] + router.urls + product_router.urls + cart_router.urls 
-----------------------
-----------------------
store::views.py=> 
-----------------------
-----------------------

from rest_framework.response import Response #serializers to Json formater
from store.models import Products,Collections,OrderItems,Review,Cart,CartItem,Customers,Order, OrderItems
from store.serializers import ProductSerializer,CollectionsSerializer,ReviewSerializer,CartSerializer,CartItemSerializer,AddCartItemSerializer,UpdateCartItemSerializer,CustomerSerializer, OrderSerializer
from django.db.models import Count



from rest_framework.viewsets import ModelViewSet
from django_filters.rest_framework import DjangoFilterBackend# filter easyly with any Db.coloumn like price ...
from rest_framework.filters import SearchFilter,OrderingFilter # for search,sorting -> product 
from rest_framework.pagination import PageNumberPagination #paginations
from .filters import ProductFilter 
from store.paginations import DefaultPagination #cutom paginations.

#import for cart:
from rest_framework.mixins import CreateModelMixin,RetrieveModelMixin,ListModelMixin,DestroyModelMixin,UpdateModelMixin
from rest_framework.viewsets import GenericViewSet
from .permissions import IsAdminOrReadOnly

class ProductViewSet(ModelViewSet):

    queryset = Products.objects.all()
    serializer_class = ProductSerializer

    #for filter: =>-------------------------
    filter_backends = [DjangoFilterBackend,SearchFilter,OrderingFilter]
    # pagination_class = PageNumberPagination
    pagination_class = DefaultPagination  #custom paginations
    # filterset_fields = ['collections_id']
    filterset_class = ProductFilter #import form custom file.
    search_fields  = ['title', 'describtion'] #search box working with those fields.
    ordering_fields = ['unit_price','last_update']
    permission_classes = [IsAdminOrReadOnly]



    def get_serializer_context(self): #for serializer extra variable /mehtod to send to serializer
        return {'request':self.request}
    
    def destroy(self, request, *args, **kwargs):
          if OrderItems.objects.filter(product__id=kwargs['pk']).count() > 0:  #aggregations-> count(), ORM query fn-> Count().
                return Response({"error": "product can't be delete cause in orderitem"},)
         
          return super().destroy(request, *args, **kwargs)
  




# --------------------------------collections-------------------------------------



class CollectionViewSet(ModelViewSet):
        permission_classes = [IsAdminOrReadOnly]
        
        queryset = Collections.objects.annotate(products_count=Count('products')).all()
        serializer_class = CollectionsSerializer
        

        def destroy(self, request, *args, **kwargs):
             if OrderItems.products.filter(product__id=kwargs['pk']).count() > 0:  # Changed 'collection' to 'collection'
                return Response({'error': "collections can't be deleted because order items are included"})
             
             return super().destroy(request, *args, **kwargs)
       

class ReviewViewSet(ModelViewSet):
     #cutom query : cz reviews show for every product : filter review for indivisual products.
     def get_queryset(self):
         return Review.objects.filter(product_id =self.kwargs['product_pk'])
     

     #use this method for => send data to Review serializer
     def get_context_data(self) :
         return {'product_id':self.kwargs['product_pk']}
     
     
     serializer_class = ReviewSerializer


class CartViewSet(CreateModelMixin,RetrieveModelMixin,ListModelMixin,DestroyModelMixin,GenericViewSet):
     
    #  queryset = Cart.objects.all()
     queryset = Cart.objects.prefetch_related('items__product').all() #cart -> Fk-> CartItem(related_name=items), instide cartItem Fk-> Products(product) | optimize the query
     serializer_class = CartSerializer


#show single items of cart: 
class CartItemViewSet(ModelViewSet): #tabels need , cart_id, product_id, quantity in DB.
   
    #allow http method : 
    http_method_names = ['get', 'post','patch','delete'] #declare those methods which we want to use.

    #for add cartItem use custom serializer: 
    def get_serializer_class(self):
         if self.request.method == "POST":
              return AddCartItemSerializer #use for add new cartItem.
         elif self.request.method == "PATCH":
              return UpdateCartItemSerializer
         
         return CartItemSerializer # use for get() cartItem.
    

    def get_serializer_context(self): #data collect from urls , then send to serializer 
         return {'cart_id':self.kwargs['cart_pk']}
   


     #need single cartItem hast cart_id column , so need cart_ID+ to catch  :
    def get_queryset(self):
          return CartItem.objects.\
                        filter(cart_id=self.kwargs['cart_pk']).\
                        select_related('product')



#------------------------------Customer user -> JESON WEB TOKEN-------------------------------------------

from rest_framework.decorators import action #get, put, delete ...details = retrive...
from rest_framework.permissions import IsAuthenticated,AllowAny,DjangoModelPermissions,DjangoModelPermissionsOrAnonReadOnly#permisson for users
from .permissions import FullDjangoModelPermission,ViewCustomerModelPermission #cutom permission.

class CustomerViewSet(ModelViewSet):
     queryset = Customers.objects.all()
     serializer_class = CustomerSerializer
     permission_classes = [DjangoModelPermissionsOrAnonReadOnly] #use our custom class : FullDjangoModelPermission.


     @action(detail=True, permission_classes=[ViewCustomerModelPermission]) #custom model permission
     def history(self,request,pk):#http://127.0.0.1:8000/store/customer/1/history....
          return Response('ok')
     
     @action(detail=False, methods=['GET','PUT'], permission_classes=[IsAuthenticated()])
     def me(self, request):#http://127.0.0.1:8000/store/customer/me/ -> this /me = def me(function). & request.user -> anonimus functions of classes.
          customer, created = Customers.objects.get_or_create(user_id=request.user.id) #get_or_create -> method return 2 value: cutomerID, created/not_created boolean

          if request.method == 'GET':#also show the user id , but user_id can't edit by user. that's why make the CustomerSerializer -> user_id(read_only)
               serializer = CustomerSerializer(customer)
               return Response(serializer.data)

          elif request.method == 'PUT':
               serializer = CustomerSerializer(customer, data=request.data)
               serializer.is_valid(raise_exception=True)
               serializer.save()
               return Response(serializer.data)



# --------------------------------------order viewset----------------------------------------------

from .serializers import OrderSerializer,CreateOrderSerializer,OrderItemSerializer,UpdateOrderSerializer
from rest_framework.permissions import IsAdminUser, IsAuthenticated

class OrderViewSet(ModelViewSet):
    permission_classes = [IsAuthenticated]
    #ALLOW THE METHOD 
    http_method_names = ['get', 'put','patch','delete','options']

    #route permission: 
    def get_permissions(self):
        if self.request.method in ['PATCH','DELETE']:
             return [IsAdminUser()] 
        return [IsAuthenticated()]

    #after createing the orderItem user can the order: that's why use this create methods.
    def create(self, request, *args, **kwargs):
        serializer = CreateOrderSerializer(data=request.data, context={'user_id': self.request.user.id})
        serializer.is_valid(raise_exception=True)
        order = serializer.save()
        serializer = OrderItemSerializer(order)
        return Response(serializer.data)


    def get_serializer_class(self):
        if self.request.method == "POST":
            return CreateOrderSerializer
        elif self.request.method == "PUT":
             return UpdateOrderSerializer
        return OrderSerializer

    def get_serializer_context(self): 
        return {'user_id': self.request.user.id} #send to serializer the user.id....

    def get_queryset(self):
        user = self.request.user

        if user.is_staff: #if user hast permission as an stuff then can see the order.
            return Order.objects.all()

        customer, created = Customers.objects.only('id').get_or_create(user_id=user.id)
        return Order.objects.filter(customers=customer) #send to the serializer 


-----------------------
-----------------------
store.serializer.py-> 
-----------------------
-----------------------
from decimal import Decimal
from rest_framework import serializers
from store.models import Products,Collections,Review,Cart,CartItem,Customers,Order,OrderItems

class ProductSerializer(serializers.ModelSerializer):
    

    class Meta : 
        model = Products
        fields = ['title', 'price', 'collections','price_with_tax','inventory','describtion'] #first search fields form model , if not find . then search => price , collections, tax_with price

  
    price = serializers.DecimalField(max_digits=6, decimal_places=2, source='unit_price') #custome name price => comes from unit_prime -> product(model)
    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')

    def calculate_tax(self, product:Products):
        return product.unit_price * Decimal(1.1)



class CollectionsSerializer(serializers.ModelSerializer):
    products_count = serializers.IntegerField(read_only=True)  # Add this line

    class Meta: 
        model = Collections
        fields = ['id', 'title', 'products_count']

        


class ReviewSerializer(serializers.ModelSerializer):

    class Meta: 
        model = Review
        fields = ['id', 'date','name', 'describtion','product']

    #Receive data from context method form views.Reveiws (product_id, reviews_also )
    def create(self,validated_data):
        product_id = self.context ['product_id']
        return Review.objects.create(product_id=product_id,**validated_data)




#Cart take cartItems from CartItem serializers (parent - cart , child - cartItem):----------------------------

class SimpleProductSerializer(serializers.ModelSerializer):

    class Meta:
        model = Products
        fields = ['pk', 'title','unit_price']


class CartItemSerializer(serializers.ModelSerializer):
    product = SimpleProductSerializer() 
    total_price = serializers.SerializerMethodField()

    def get_total_price(self, cart_item: CartItem):
        return cart_item.quantity * cart_item.product.unit_price

    class Meta:
        model = CartItem
        fields = ['id', 'product', 'quantity', 'total_price']


class AddCartItemSerializer(serializers.ModelSerializer):
    product_id = serializers.IntegerField()

    class Meta:
        model = CartItem 
        fields = ['id','product_id','quantity'] #those field get from DB . if need extra data in varibale then we use self.request -> get data from url through get_context(self.kwagrs['paramsName-which get from urls/users']) for serializer.

    #data validation which get from url/users: if user input wrong product_id then => 
    def validate_product_id(self,value):
        if not Products.objects.filter(pk=value).exists():
            raise serializers.ValidationError('No Product Fount with the given ID')
        return value
    
    def save(self, **kwargs): #*** in serializer can't get params from urls , that's why use get_context() method in views to pass data into serializer.
        #in views we are using => serializer.is_validate():  -> serializer.save() 
        cart_id = self.context['cart_id'] #get from  views.context(method)
        product_id = self.validated_data['product_id'] #get from  urls
        quantity = self.validated_data['quantity'] #get from  urls

        try:
            cart_item = CartItem.objects.get(cart_id=cart_id, product_id=product_id)  #if get cart item then just update cartItem. and increase the quantity.
            cart_item.quantity += quantity
            cart_item.save()
            self.instance = cart_item#if Model get any data then update and return instance
        except CartItem.DoesNotExist:
            product = Products.objects.get(pk=product_id)
            self.instance = CartItem.objects.create(cart_id=cart_id, product=product, quantity=quantity)#if not found any cartItem then create new Item
             #  or user => 
             #  self.instance = CartItem.objects.create(cart_id=cart_id, **self.validated_data)
        return self.instance #if model not get any data then create new instance then return to db.


class UpdateCartItemSerializer(serializers.ModelSerializer):

    class Meta : 
        model = CartItem 
        fields = ['quantity']

        




class CartSerializer(serializers.ModelSerializer):
    id = serializers.UUIDField(read_only=True)
    items = CartItemSerializer(many=True, read_only=True )  # Set read_only=True
    total_price = serializers.SerializerMethodField()

    def get_total_price(self,cart:Cart):
        return sum([item.quantity * item.product.unit_price for item in cart.items.all()]) #most important Line.

    class Meta:
        model = Cart
        fields = ['id', 'items', 'total_price']



# ----------------------------------Customer Serializer-------------------------------------------------------

class CustomerSerializer(serializers.ModelSerializer):
    user_id = serializers.IntegerField(read_only=True)

    class Meta: 
        model = Customers
        fields = ['id', 'user_id', 'phone', 'email', 'birth_date', 'membership']








# ----------------------------------OrderItem Serializer-------------------------------------------------------

class OrderItemSerializer(serializers.ModelSerializer):
    product = SimpleProductSerializer()

    class Meta: 
        model = OrderItems
        fields = ['id', 'product', 'unit_price', 'quantity']




# ----------------------------------Order Serializer-------------------------------------------------------

class OrderSerializer(serializers.ModelSerializer):

    items = OrderItemSerializer(many=True)

    class Meta:
        model = Order
        fields = ['id','payment_status', 'customers', 'place_order','items' ]


# ----------------------------------------Create OrderSerializer--------------------------------------------
from django.db import transaction
import uuid
class CreateOrderSerializer(serializers.Serializer):
     #we are not uing the model serializer here...

       #for real life senerio for creating order , we collect data from cart . that's why we use cart_id varibale here .
    cart_id = serializers.UUIDField()#for creating the order we collect cart_ID ,

    
    #if cart_id does not exit then user can't create the order: 
   
    
    
    def validate_cart_id(self, cart_id):
        if not Cart.objects.filter(pk=cart_id).exists() and Cart.objects.filter(pk=cart_id).count()==0 :
            raise serializers.ValidationError('Cart ID not found!')
        elif CartItem.objects.filter(cart_id=cart_id).count()==0:
            raise serializers.ValidationError('Cart is Empty!')
        return cart_id
  

    def save(self, user_id, **kwargs):
        with transaction.atomic():
            cart_id = self.validated_data['cart_id']#get from user form...
            user_id = self.context.get('user_id')#get from views.
            customer, created = Customers.objects.get_or_create(user_id=user_id)
            order = Order.objects.create(customers=customer)


            #for creating the order items : --------------------------------------------------------
        
            #create a cart_id then create a cart_items: then create OrderItems.
            #using CartItem model for filter card_id from cart table.(then we get the product )
            cart_items = CartItem.objects.filter(cart_id=cart_id).select_related('product')

            order_items = [
                OrderItems(
                    order=order,
                    product=item.product,
                    unit_price=item.product.unit_price,
                    quantity=item.quantity
                )
                for item in cart_items
            ]

            OrderItems.objects.bulk_create(order_items)

            #now delete the cartItem cz we use it for creating OrderItems: 

             # Corrected deletion of cart items
            CartItem.objects.filter(cart_id=cart_id).delete()

            return order #return to the views-> create()

            #we using the model operations=>  order,OrderItem,CartItem, then delete the cartItem ,so if 1 operations 
            #fail then other operations working not properly .... if 1 operation is not work then otherOperations 
            #will stop. that's why we use Tracsictions ORM methods.


# -----------------------------------Udpdate serializers----------------------------------

class UpdateOrderSerializer(serializers.ModelSerializer):
    #just only update the payment_status
    class Meta: 
        model = Order 
        fields = ['payment_status']




-----------------------
-----------------------
models.py=> 
-----------------------
-----------------------
from django.db import models
from uuid import uuid4 #for generate cart unique number.

#import for users links with profile: 
from django.conf import settings
#improt admin for display first_name, last_name as ordering : 
from django.contrib import admin

# Create your models here.


class Promotions(models.Model):
    describtion = models.CharField(max_length=255)
    discount = models.FloatField()


class Collections(models.Model):
    title = models.CharField(max_length=255)
    featured_product = models.ForeignKey('Products',on_delete=models.SET_NULL, null=True, related_name='+')

    def __str__(self):
        return self.title 
    
    class Meta:
        ordering = ['title']

    


class Products (models.Model):
    slug = models.SlugField()
    sku = models.CharField(max_length=10)
    title = models.CharField(max_length=255)
    describtion = models.TextField()
    unit_price = models.DecimalField(max_digits=10, decimal_places=2) 
    inventory = models.IntegerField()
    last_update = models.DateTimeField(auto_now=True)
    collections = models.ForeignKey(Collections,on_delete=models.PROTECT,related_name='products') # if want to delete Collections , Before must be delete Products .
    promotions = models.ManyToManyField(Promotions)

    def __str__(self) -> str:
        return self.title
    
    class Meta: 
        ordering = ['title']




# class Customers(models.Model):
#     MEMBERSHIP_BRONZE = 'B'
#     MEMBERSHIP_SLIVER = 'S'
#     MEMBERSHIP_GOLD = 'G'
#     MEMBERSHIP_CHOICE = [
#     ('MEMBERSHIP_BRONZE','Bronze'),
#     ('MEMBERSHIP_SLIVER','Silver'),
#     ('MEMBERSHIP_GOLD','Gold'),
#     ]

#     first_name = models.CharField(max_length=255)
#     last_name = models.CharField(max_length=255)
#     email = models.EmailField(unique=True)
#     phone = models.IntegerField()
#     brith_date = models.DateField(null=True)
#     membership = models.CharField(max_length=17, choices=MEMBERSHIP_CHOICE, default=MEMBERSHIP_BRONZE)
#     # orders = models.ManyToManyField(Order)
#     #Link to the user Model: 
#     user = models.OneToOneField(settings.AUTH_USER_MODEL,on_delete=models.CASCADE)


#     # def __str__(self):
#     #     return f"{self.first_name} {self.last_name }"
    

#     #this 2 functions pass to admin.py=> 
#     @admin.display(ordering='user__first_name')
#     def first_name(self):
#         return self.user.first_name
    
#     @admin.display(ordering='user__last_name')
#     def last_name(self):
#         return self.user.last_name
    
    
#     def get_order_count(self):
#         return self.order_set.count()


#     class Meta:
#         ordering = ['user__first_name', 'user__last_name']



class Customers(models.Model):
    MEMBERSHIP_BRONZE = 'B'
    MEMBERSHIP_SILVER = 'S'
    MEMBERSHIP_GOLD = 'G'
    MEMBERSHIP_CHOICES = [
        ('MEMBERSHIP_BRONZE', 'Bronze'),
        ('MEMBERSHIP_SILVER', 'Silver'),
        ('MEMBERSHIP_GOLD', 'Gold'),
    ]

    first_name = models.CharField(max_length=255)
    last_name = models.CharField(max_length=255)
    email = models.EmailField(unique=True)
    phone = models.IntegerField(null=True)
    birth_date = models.DateField(null=True)
    membership = models.CharField(max_length=17, choices=MEMBERSHIP_CHOICES, default=MEMBERSHIP_BRONZE)
    user = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)

    @admin.display(ordering='user__first_name')
    def first_name(self):
        return self.user.first_name
    
    @admin.display(ordering='user__last_name')
    def last_name(self):
        return self.user.last_name
    
    def get_order_count(self):
        return self.order_set.count()

    class Meta:
        ordering = ['user__first_name', 'user__last_name']


        #custom model permission: 
        permissions = [('view_history', 'Can view history')]
        #then run >>> python manage.py makemigrations, migrate...


class Order(models.Model):
    PAYMENT_STATUS_PENDING = 'P'
    PAYMENT_STATUS_COMPLETE = 'C'
    PAYMENT_STATUS_FAILD = 'F'
    PAYMENT_STATUS_CHOICE = [
        ('PAYMENT_STATUS_PENDING','P'),
        ('PAYMENT_STATUS_COMPLETE','C'),
        ('PAYMENT_STATUS_FAILD','F'),
    ]
    place_order = models.DateTimeField(auto_now_add=True)
    payment_status = models.CharField(
    max_length=23, choices=PAYMENT_STATUS_CHOICE, default=PAYMENT_STATUS_PENDING
    )

    customers = models.ForeignKey(Customers, on_delete=models.PROTECT) #if accidently delete the Customers , we don't delete the order .

    class Meta: 
        permissions=[
            ('cancel_order', 'Can cancel Order')
        ]


class OrderItems(models.Model):
    order = models.ForeignKey(Order,on_delete=models.PROTECT, related_name='items')
    product = models.ForeignKey(Products,on_delete=models.PROTECT, related_name='orderItems')
    quantity = models.PositiveSmallIntegerField()
    unit_price = models.DecimalField(max_digits=6,decimal_places=2)

class Cart(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid4)
    created_at = models.DateTimeField(auto_now_add=True)

class Address(models.Model):
    street = models.CharField(max_length=255)  # Corrected max_length
    city = models.CharField(max_length=255)  
    

    #one to one relationship
    Customers = models.OneToOneField(Customers,on_delete=models.CASCADE, primary_key=True ) 

class CartItem(models.Model):
    cart = models.ForeignKey(Cart,on_delete=models.CASCADE, related_name='items') #
    product = models.ForeignKey(Products,on_delete=models.CASCADE)
    quantity = models.PositiveSmallIntegerField()

    unique_together = [['cart','products']] #for unique generated....



class Review(models.Model):
    product = models.ForeignKey(Products,on_delete=models.CASCADE, related_name='review')
    name = models.CharField(max_length=255)
    describtion = models.TextField()
    date = models.DateField(auto_now_add=True)
-----------------------


-------------------------------------------------------------------------------------------------------------
----------------------------------------Singnal---------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
function fire with save or delete data into DB as pre/post.


store::signal.py=> 
------------------
from django.conf import settings #for custom user model.
from django.db.models.signals import post_save 
from django.dispatch import receiver
from .models import Customers


@receiver(post_save, sender=settings.AUTH_USER_MODEL)
def create_customer_for_new_user(sender,**kwargs):
    if kwargs['created']:
        Customers.objects.create(user=kwargs['instance'])

--------------------
store::apps.py=> 
--------------------
--------------------
from django.conf import settings 
from django.db.models.signals import post_save 
from django.dispatch import receiver
from .models import Customers


@receiver(post_save, sender=settings.AUTH_USER_MODEL)
def create_customer_for_new_user(sender,**kwargs):
    if kwargs['created']:
        Customers.objects.create(user=kwargs['instance'])


-------------------------------------------------------------------------------------------------------------
---------------------------------custom Singnal when creating order then notify----------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------

store::signal::__init__.py=> 
----------------------------
----------------------------
from django.dispatch import Signal

order_created = Signal()
----------------------------
----------------------------
store::serializer.py=> 
----------------------------
----------------------------
from django.db import transaction
from .singnals import order_created #
class CreateOrderSerializer(serializers.Serializer):
     #we are not uing the model serializer here...

       #for real life senerio for creating order , we collect data from cart . that's why we use cart_id varibale here .
    cart_id = serializers.UUIDField()#for creating the order we collect cart_ID ,

    
    #if cart_id does not exit then user can't create the order: 
   
    
    
    def validate_cart_id(self, cart_id):
        if not Cart.objects.filter(pk=cart_id).exists() and Cart.objects.filter(pk=cart_id).count()==0 :
            raise serializers.ValidationError('Cart ID not found!')
        elif CartItem.objects.filter(cart_id=cart_id).count()==0:
            raise serializers.ValidationError('Cart is Empty!')
        return cart_id
  

    def save(self, **kwargs):
        with transaction.atomic():
            cart_id = self.validated_data['cart_id']#get from user form...
            user_id = self.context.get('user_id')#get from views.
            customer, created = Customers.objects.get_or_create(user_id=user_id)
            order = Order.objects.create(customers=customer)


            #for creating the order items : --------------------------------------------------------
        
            #create a cart_id then create a cart_items: then create OrderItems.
            #using CartItem model for filter card_id from cart table.(then we get the product )
            cart_items = CartItem.objects.filter(cart_id=cart_id).select_related('product')

            order_items = [
                OrderItems(
                    order=order,
                    product=item.product,
                    unit_price=item.product.unit_price,
                    quantity=item.quantity
                )
                for item in cart_items
            ]

            OrderItems.objects.bulk_create(order_items)

            #now delete the cartItem cz we use it for creating OrderItems: 

         

            #created singnal fn instance: 
            order_created.send_robust(self.__class__, order = order) #when created the order signal generated.
            
            # Corrected deletion of cart items
            CartItem.objects.filter(cart_id=cart_id).delete()
            return order #return to the views-> create()

            #we using the model operations=>  order,OrderItem,CartItem, then delete the cartItem ,so if 1 operations 
            #fail then other operations working not properly .... if 1 operation is not work then otherOperations 
            #will stop. that's why we use Tracsictions ORM methods.
----------------------------
----------------------------
core::handler.py=>
----------------------------
----------------------------
from django.dispatch import receiver
from store.singnals import order_created #__init.py form store.signal folder.


@receiver(order_created)
def on_order_created(sender,**kwargs):
    print(kwargs['order'])
----------------------------
----------------------------
core::app.py=> 
----------------------------
----------------------------
from django.apps import AppConfig


class CoreConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'core'

    def ready(self) -> None:
        import core.signal.handler



