# **`fn(*args, **kwargs)` - Complete Guide**

## **What is `*args` and `**kwargs`?**

### **`*args`** - Variable Positional Arguments
```python
def example(*args):
    print(f"Args: {args}")
    print(f"Type: {type(args)}")  # Always tuple

example(1, 2, 3)           # Args: (1, 2, 3)
example("a", "b")          # Args: ('a', 'b')
example()                  # Args: ()
```

### **`**kwargs`** - Variable Keyword Arguments
```python
def example(**kwargs):
    print(f"Kwargs: {kwargs}")
    print(f"Type: {type(kwargs)}")  # Always dict

example(name="Alice", age=25)  # Kwargs: {'name': 'Alice', 'age': 25}
example(x=1, y=2)             # Kwargs: {'x': 1, 'y': 2}
example()                     # Kwargs: {}
```

## **1. Using `*args` and `**kwargs` Together**
```python
def universal_function(*args, **kwargs):
    print(f"Positional arguments: {args}")
    print(f"Keyword arguments: {kwargs}")

universal_function(1, 2, 3, name="Alice", age=25)
```
**Output:**
```
Positional arguments: (1, 2, 3)
Keyword arguments: {'name': 'Alice', 'age': 25}
```

## **2. Why Use in Decorators?**
```python
def logger_decorator(func):
    def wrapper(*args, **kwargs):  # Accept ANY arguments
        print(f"Calling {func.__name__} with: args={args}, kwargs={kwargs}")
        result = func(*args, **kwargs)  # Pass ALL arguments to original function
        print(f"Function returned: {result}")
        return result
    return wrapper

@logger_decorator
def greet(name, age, city="Unknown"):
    return f"Hello {name}, age {age} from {city}"

# All these work perfectly:
greet("Alice", 25)
greet("Bob", 30, city="New York")
greet("Charlie", age=35, city="London")
```

```python
# ---------------------------------------- controll the function call by decorator -------------------
def repeat(times):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(times):
                func(*args, **kwargs)
        return wrapper
    return decorator

@repeat(times=2)
def greet(name):
    print(f"Hello, {name}!")

greet("Alice")

┌──(ashraful㉿kali)-[~/Instasure/MicroService_Python/Python]
└─$ python decorator.py
Hello, Alice!
Hello, Alice!
```

## **3. Step-by-Step Breakdown**

### **Without `*args, **kwargs` (PROBLEM)**
```python
def bad_decorator(func):
    def wrapper():  # ❌ No parameters
        print("Before")
        func()      # ❌ Can't pass arguments
        print("After")
    return wrapper

@bad_decorator
def say_hello(name):
    print(f"Hello {name}")

say_hello("Alice")  # ❌ TypeError: wrapper() takes 0 positional arguments...
```

### **With `*args, **kwargs` (SOLUTION)**
```python
def good_decorator(func):
    def wrapper(*args, **kwargs):  # ✅ Accepts any parameters
        print("Before")
        func(*args, **kwargs)      # ✅ Passes all parameters
        print("After")
    return wrapper

@good_decorator
def say_hello(name):
    print(f"Hello {name}")

say_hello("Alice")  # ✅ Works!
```

## **4. Real-World Decorator Examples**

### **Timing Decorator**
```python
import time

def timer(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} took {end-start:.4f} seconds")
        return result
    return wrapper

@timer
def expensive_operation(n):
    time.sleep(1)
    return n * n

result = expensive_operation(5)  # Works with parameters!
```

### **Validation Decorator**
```python
def validate_non_negative(func):
    def wrapper(*args, **kwargs):
        # Check all positional arguments
        for arg in args:
            if isinstance(arg, (int, float)) and arg < 0:
                raise ValueError("Negative values not allowed")
        
        # Check all keyword arguments  
        for key, value in kwargs.items():
            if isinstance(value, (int, float)) and value < 0:
                raise ValueError(f"Negative value for {key}")
        
        return func(*args, **kwargs)
    return wrapper

@validate_non_negative
def create_person(name, age, salary=0):
    return f"{name}, {age} years, salary: ${salary}"

print(create_person("Alice", 25, salary=50000))
# print(create_person("Bob", -5))  # ❌ Would raise ValueError
```

## **5. Advanced Usage**

### **Modifying Arguments**
```python
def to_uppercase(func):
    def wrapper(*args, **kwargs):
        # Convert all string args to uppercase
        new_args = [arg.upper() if isinstance(arg, str) else arg for arg in args]
        new_kwargs = {k: v.upper() if isinstance(v, str) else v for k, v in kwargs.items()}
        
        return func(*new_args, **new_kwargs)
    return wrapper

@to_uppercase
def process_text(name, description, category="general"):
    return f"{name} - {description} [{category}]"

print(process_text("hello", "world", category="test"))
# Output: HELLO - WORLD [TEST]
```

### **Conditional Execution**
```python
def skip_if_none(func):
    def wrapper(*args, **kwargs):
        if any(arg is None for arg in args):
            print("Skipping function - None value detected")
            return None
        return func(*args, **kwargs)
    return wrapper

@skip_if_none
def multiply(a, b):
    return a * b

print(multiply(5, 3))    # 15
print(multiply(5, None)) # Skipping function - None value detected
```

## **6. Common Patterns**

### **Decorator with Its Own Arguments + `*args, **kwargs`**
```python
def repeat(n_times):
    def decorator(func):
        def wrapper(*args, **kwargs):
            results = []
            for _ in range(n_times):
                result = func(*args, **kwargs)
                results.append(result)
            return results
        return wrapper
    return decorator

@repeat(3)
def say_hello(name):
    return f"Hello {name}"

print(say_hello("Alice"))
# Output: ['Hello Alice', 'Hello Alice', 'Hello Alice']
```

## **Key Takeaways:**

1. **`*args`** collects positional arguments into a tuple
2. **`**kwargs`** collects keyword arguments into a dictionary  
3. **Always use** `*args, **kwargs` in decorator wrappers
4. **Pass them through** to the original function: `func(*args, **kwargs)`
5. **Makes decorators universal** - work with any function signature

This pattern makes your decorators flexible and reusable across different functions!
